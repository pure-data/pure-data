<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> externals | Pd Manual </title>
    <meta http-equiv="Content-Type" content="text/html">
    <link rel="stylesheet" type="text/css" href="./x/css/pdmanual.css" media="screen">
	<link rel="icon" type="image/png" href="./x/favicon.ico">
  </head>
  <body>
    <div id=corpus>
      <main><h2 id="pd-manual-externals">Pd Manual: externals</h2>
<p><a href="index.html">back to table of contents</a></p>
<h3 id="externals">Externals</h3>
<p>This section explains what are external objects and libraries. It also
describes everything on how to install and load them in Pure Data.</p>
<p>You can write your own external objects that you and others can use in
their Pd applications in C or (if you&rsquo;re smart and brave) in C++ or
FORTRAN. In the &ldquo;6.externs&rdquo; subdirectory of the documentation you can
find simple examples of externals with their source code and test
patches.</p>
<p>There&rsquo;s also an excellent guide to writing externals project by IOhannes
zm√∂lnig at <a href="https://github.com/pure-data/externals-howto">https://github.com/pure-data/externals-howto</a>. Check also
the pd-lib-builder project (a helper makefile for Pure Data external
libraries by Katja Vetter) at
<a href="http://github.com/pure-data/pd-lib-builder">http://github.com/pure-data/pd-lib-builder</a></p>
<h3 id="external-objects--libraries">External Objects &amp; Libraries</h3>
<h3 id="what-are-vanilla-objects-internals--externals">What are: Vanilla Objects, Internals &amp; Externals?</h3>
<p>Internal objects come as part of the Pd binary, whereas external objects
are separate from it. The main Pd distribution (a.k.a. &ldquo;Pd Vanilla&rdquo;)
also comes with a few &ldquo;extra&rdquo; objects that are not part of its binary.
Therefore, the set of &ldquo;vanilla objects&rdquo; (the built-in objects in Pd)
include internals and externals. Nonetheless, &ldquo;externals&rdquo; mostly refer
objects not available in the Pd Vanilla distribution, that you need to
download and install them properly so they can be loaded into Pd
patches.</p>
<p>To get a full list of all objects in Pd Vanilla, go to the <strong>Help</strong> menu
and then select <strong>List of Objects</strong>, or alternatively right click on an
empty spot of a patch&rsquo;s window and select &ldquo;help&rdquo; - this loads the
help-intro.pd file (see below).</p>
<p><img src="x/img/fig4.1.png" alt=""></p>
<p>The set of externals that come with Pd are available in the &rsquo;extra'
library and is located in a folder named &ldquo;extra&rdquo; inside the Pd
application. These appear at the very end of the &ldquo;help-intro.pd&rdquo; and can
also be viewed in the Help Browser menu (Help =&gt; Browser). See figure
below, which shows how the browser looks in a fresh install of Pd and
lists the objects in the extra folder.</p>
<p><img src="x/img/fig4.2.png" alt=""></p>
<h3 id="what-are-the-types-of-external-objects">What are the Types of External Objects?</h3>
<p>An object in Pd can be either a patch - meaning a Pd file (a.k.a
abstraction) - or a compiled binary (note that a binary can contain only
one or several external objects, as discussed further on).</p>
<h3 id="compiled-objects">Compiled objects:</h3>
<p>These are Pd objects compiled to binaries from programming code (like in
C or C++). They have to be compiled for your operating system, which
means the binaries have different extensions according to each platform.
For instance:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operating System</th>
<th style="text-align:center">CPU-architecture</th>
<th style="text-align:center">filename</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Linux</td>
<td style="text-align:center"><em>unspecified</em> (any architecture)</td>
<td style="text-align:center"><code>my_lib.pd_linux</code></td>
</tr>
<tr>
<td style="text-align:center">Linux</td>
<td style="text-align:center">i386 (Intel/AMD 32bit)</td>
<td style="text-align:center"><code>my_lib.l_i386</code></td>
</tr>
<tr>
<td style="text-align:center">Linux</td>
<td style="text-align:center">amd64 (Intel/AMD 64bit)</td>
<td style="text-align:center"><code>my_lib.l_amd64</code></td>
</tr>
<tr>
<td style="text-align:center">Linux</td>
<td style="text-align:center">arm (e.g. RaspberryPi)</td>
<td style="text-align:center"><code>my_lib.l_arm</code></td>
</tr>
<tr>
<td style="text-align:center">Linux</td>
<td style="text-align:center">arm64</td>
<td style="text-align:center"><code>my_lib.l_arm64</code></td>
</tr>
<tr>
<td style="text-align:center">macOS</td>
<td style="text-align:center"><em>unspecified</em> (any architecture)</td>
<td style="text-align:center"><code>my_lib.pd_darwin</code></td>
</tr>
<tr>
<td style="text-align:center">macOS</td>
<td style="text-align:center">fat (multiple archs)</td>
<td style="text-align:center"><code>my_lib.d_fat</code></td>
</tr>
<tr>
<td style="text-align:center">macOS</td>
<td style="text-align:center">PowerPC</td>
<td style="text-align:center"><code>my_lib.d_ppc</code></td>
</tr>
<tr>
<td style="text-align:center">macOS</td>
<td style="text-align:center">i386 (Intel 32bit)</td>
<td style="text-align:center"><code>my_lib.d_i386</code></td>
</tr>
<tr>
<td style="text-align:center">macOS</td>
<td style="text-align:center">amd64 (Intel 64bit)</td>
<td style="text-align:center"><code>my_lib.d_amd64</code></td>
</tr>
<tr>
<td style="text-align:center">macOS</td>
<td style="text-align:center">arm64 (Apple Silicon)</td>
<td style="text-align:center"><code>my_lib.d_arm64</code></td>
</tr>
<tr>
<td style="text-align:center">Windows</td>
<td style="text-align:center"><em>unspecified</em> (any architecture)</td>
<td style="text-align:center"><code>my_lib.dll</code></td>
</tr>
<tr>
<td style="text-align:center">Windows</td>
<td style="text-align:center">i386 (Intel/AMD 32bit)</td>
<td style="text-align:center"><code>my_lib.m_i386</code></td>
</tr>
<tr>
<td style="text-align:center">Windows</td>
<td style="text-align:center">amd64 (Intel/AMD 64bit)</td>
<td style="text-align:center"><code>my_lib.m_amd64</code></td>
</tr>
</tbody>
</table>
<h3 id="abstractions">Abstractions:</h3>
<p>You can have a Pd patch behave like an object by loading it into other
patches - these are usually called &ldquo;abstractions&rdquo;. Note that some of the
externals in &ldquo;extra&rdquo; are abstractions (for instance, rev1~ or
hilbert~). Like any other Pd patch, an abstraction may contain any kind
of objects (internals, compiled externals and even other abstractions).</p>
<h3 id="what-are-external-libraries">What are External Libraries?</h3>
<p>In practical terms, an external library is a collection of external
objects of any kind (abstractions or compiled objects). But when it
comes to compiled objects, a library can provide several objects as a
<strong>single binary pack</strong> or as a <strong>set of separate binaries</strong> (where each
object has its own binary).</p>
<p>The &ldquo;classic&rdquo; library format is a single binary pack (with two or more
externals), but splitting into separate binaries became a very common
practice. A single external binary (not part of any set of objects) is
still, technically, a library with just one object. But again, the
prevailing idea is that a library is just a set of objects.</p>
<p>It&rsquo;s important to note that there are differences on how externals are
loaded depending if they&rsquo;re a single binary pack or a set of separate
binaries (as explained in the next subsections).</p>
<h3 id="what-are-the-types-of-external-libraries">What are the types of External Libraries?</h3>
<p>Libraries can come in all sorts of ways; as only a collection of
abstractions (like &ldquo;list-abs&rdquo;), only compiled objects, or both. It can
even mix compiled externals both as a <strong>set of separate binaries</strong> and a
<strong>single binary pack</strong>. Basically, any combination is possible for a set
of external.</p>
<p>One example that combines all external options is <em>Cyclone</em> (since
version 0.3), which provides most of its objects as a <strong>set of separate
binaries</strong>, but also includes a small collection of 12 objects as a
<strong>single binary pack</strong> plus a few abstractions.</p>
<h3 id="wrapping-up-part-1">Wrapping up Part 1)</h3>
<ul>
<li><strong>Internal objects:</strong> Objects that are part of Pd Vanilla&rsquo;s binary.</li>
<li><strong>External objects:</strong> Objects that are <strong>NOT</strong> part of Pd
Vanilla&rsquo;s binary.</li>
<li><strong>Vanilla objects:</strong> Built-in objects in the Pd Vanilla distribution
(including internals and a small collection of externals - the
&ldquo;extra&rdquo; objects).</li>
<li><strong>Types of external objects:</strong> Compiled binaries or Abstractions.</li>
<li><strong>External Library:</strong> Collection of external objects in any form, be
it a <em>&ldquo;single binary pack&rdquo;</em> containing several objects, a
<em>&ldquo;set of separate binaries&rdquo;</em> / <em>abstractions</em> or any
combination of them.</li>
</ul>
<hr>
<h3 id="installing-external-objects-and-libraries">Installing External Objects and Libraries</h3>
<p>Installing externals in Pd is quite simple, all you need to do is
download your externals from somewhere, such as from Pd Vanilla
directly, and include them in a proper folder.</p>
<h3 id="where-to-include-the-externals">Where to include the externals?</h3>
<p>Currently, when launching for the first time with a fresh install, Pd
asks if you want to create a documents directory for patches that
includes an &ldquo;externals&rdquo; subdirectory. This externals folder is where
it&rsquo;s advised to include external libraries and it&rsquo;s automatically
included in the user added search paths (under Preferences =&gt; Path),
see figure below.</p>
<p><img src="x/img/fig4.3.png" alt=""></p>
<p>We see in the screenshot above that the &ldquo;Pd&rdquo; folder is created under
~/Documents, and inside it we have the externals subfolder. Even if you
did not create this folder, here is where you can create it by clicking
the &ldquo;Reset&rdquo; button under &ldquo;Pd Documents Directory&rdquo;.</p>
<p>Externals can actually be anywhere in your computer, but Pd must know
where to look for them. Pd looks for files (including externals) in the
user added search paths, but it also searches in other folders not
listed there such as: the same folder that your patch is saved on (the
<strong>Relative Path</strong>) and the <strong>Standard Paths</strong>, which
are:</p>
<ul>
<li>A) <strong>Application-specific</strong>: The &ldquo;extra&rdquo; folder inside
a particular Pure Data application.</li>
<li>B) <strong>User-specific</strong>: A system folder for a specific user
in the machine.</li>
<li>C) <strong>Global</strong>: A system folder for all users on the
machine.</li>
</ul>
<p>Officially, there&rsquo;s only one &lsquo;Standard Path&rsquo; which is the &rsquo;extra&rsquo;
folder. The others are not automatically created by Pd and are part of
an old structure. Currently, the best practice is to use the default
external folders or user added paths, but these other options are
documented here anyway and may be useful in some edge cases.</p>
<p>The <strong>Global</strong> folder affects all Pure Data Applications for
all users. The <strong>User-specific</strong> folder affects all Pure Data
Applications for that user. And since you can have different versions of
Pd installed in your system, the <strong>Application-specific</strong>
folder affects only that particular Pd Application - multiple Pd
applications can be of different versions (an older and a newer one or
both 32-bit and 64-bit). For reference, here&rsquo;s the list of the Standard
Paths for all operating systems:</p>
<p>A) macOS:</p>
<ul>
<li><strong>Application-specific</strong>:
<code>/$PdPath/Contents/Resources/extra</code> - this is inside the
Pd Application (like Pd-0.49-1 in <code>~/Applications</code>); right click it
and choose &ldquo;Show Package Contents&rdquo;, then navigate to
<code>Resources/extra</code>.</li>
<li><strong>User-specific</strong>: <code>~/Library/Pd</code>
(<code>/Users/user_name/Library/Pd</code>)</li>
<li><strong>Global</strong>: <code>/Library/Pd</code></li>
</ul>
<p>B) Windows:</p>
<ul>
<li><strong>Application-specific</strong>:
<code>%ProgramFiles(x86)%\Pd\extra</code> (for 64-bit OS and 32-bit
Pd) or <code>%ProgramFiles%\Pd\extra</code>; this is inside the Pd Application
(usually in <code>C:\Program Files</code>). This folder needs to be set to
writeable.</li>
<li><strong>User-specific</strong>: <code>%AppData%\Pd</code> (usually in
<code>C:\Users\user_name\AppData\Roaming\Pd</code>).</li>
<li><strong>Global</strong> <code>%CommonProgramFiles%\Pd</code>
(usually in <code>C:\Program Files\Common Files\Pd</code>).</li>
</ul>
<p>C) GNU/Linux:</p>
<ul>
<li><strong>Application-specific</strong>: <code>/usr/lib/pd/extra</code>
if installed via a package manager (apt-get) or
<code>/usr/local/lib/pd/extra</code> if compiled by yourself.</li>
<li><strong>User-specific</strong>: <code>~/.local/lib/pd/extra</code>
(preferred since version Pd-0.47-1) or <code>~/pd-externals</code> (deprecated
but still usable).</li>
<li><strong>Global</strong>: <code>/usr/local/lib/pd-externals</code></li>
</ul>
<h3 id="how-to-download-externals-from-pd-vanilla">How to Download Externals from Pd Vanilla?</h3>
<p>Since version 0.47-0, Pd Vanilla has its own external manager! This is a
built in .tcl plug-in named &ldquo;deken&rdquo; (check
<a href="https://github.com/pure-data/deken">https://github.com/pure-data/deken</a> for reference). Open it by
selecting the <strong>Help =&gt; Find externals</strong> tab. Then you can type
and search for object name, library name or both. The wildcard &lsquo;*&rsquo; can be used
to broaden the search, or an exact name can be used instead. All available versions of
the library/external specific for your operating system will be shown to you.
See figure below.</p>
<p><img src="x/img/deken.gif" alt=""></p>
<p>When you click on the version you want, by default Pd downloads it to
<code>~/Documents/Pd/externals</code>.</p>
<hr>
<h3 id="loading-externals">Loading Externals</h3>
<p>The current best practice is to use the declare object to search for,
load and manage externals, but there are alternatives.</p>
<p>If the object is from a library that is distributed as a single binary
pack, this binary needs to be pre loaded so Pd can create its externals.
This is done either with declare or manually via Preferences =&gt;
Startup.</p>
<p>If the external library only contains abstractions or objects compiled
as a set of separate binaries, Pd just needs to know its path. Again,
this can be done with declare or manually via Preferences =&gt; Path, but
yet another option here is to use slash declarations as we&rsquo;ll see
later.</p>
<h3 id="using-the-declare-object">Using the [declare] object:</h3>
<p>The declare object can be used to add search paths or load libraries.
When adding a path, it behaves quite similarly to adding search paths to
the user added paths (under Preferences =&gt; Path). The difference is
that this will only work for the patch that contains the declare
object - unlike using path, which loads permanently for any patch.</p>
<p>As for loading a library, once Pd loads it (via [declare] or startup)
it sticks with it. This means that if you use [declare] to load a
library, it will also be loaded if you create a new patch without any
[declare] object.</p>
<h3 id="declare--path">[declare -path]:</h3>
<p>Let&rsquo;s take for an example the <a href="http://github.com/porres/pd-else">ELSE</a>
library. This library contains separate binaries and abstractions, so Pd
only needs to know its location path. We then use the &lsquo;-path&rsquo; flag as
in [declare -path else]. This makes Pd look for a folder named
&rsquo;else&rsquo; to add it to the search path for that patch only. When and if
it succeeds in finding this folder with [declare], this is where Pd
will prioritize the search of objects and other files, moving on to
other possible search places if nothing is found.</p>
<p>But where does Pd look for the &rsquo;else&rsquo; folder? Well, the -path flag is
first meant to search in the Relative Path, but if it doesn&rsquo;t find it,
it falls back to the User Added Paths and Standard Paths. So let&rsquo;s say
you put the ELSE library folder in &ldquo;<code>~/Documents/Pd/externals</code>&rdquo;, which is
the current best practice, Pd will know to look for it there and will
find it!</p>
<p>Now, in the case of a single external, the best practice is to include
it in a folder with the same name in &ldquo;<code>~/Documents/Pd/externals</code>&rdquo;. An
example, the freeverb~ external should be in
&ldquo;<code>~/Documents/Pd/externals/freeverb~&quot;</code>. In this situation, you don&rsquo;t
need to add the external folder to the path, manually or use
[declare]. This is because when you tell Pd to look for an external,
if it finds a folder with the same name as the external, it&rsquo;ll know to
search inside that folder for the external!</p>
<h3 id="declare--lib">[declare -lib]:</h3>
<p>The &lsquo;-lib&rsquo; flag is needed for the classic Pd library format, which is
a single binary pack with many externals. One such example is the
<a href="https://git.iem.at/pd/zexy/">zexy</a> library. So you should download and
have the &lsquo;zexy&rsquo; folder in &ldquo;<code>~/Documents/Pd/externals/zexy</code>&rdquo;. Now you
can use [declare -lib zexy] to load the external binary. In the same
way as explained with the freeverrb~ example, the binary is inside a
folder with the same name. So Pd will search for the external in
&ldquo;<code>~/Documents/Pd/externals</code>&rdquo;, will find the &lsquo;zexy&rsquo; folder and know to
search for the zexy binary in it. This means you don&rsquo;t need to bother
in using [declare] to define the search path.</p>
<p>Note that it may be possible for you to load a library binary as an
object if the developer wished to. But it&rsquo;s still advisable to use
either &ldquo;Startup&rdquo; or [declare -lib], because this way you are sure
the library is preloaded before Pd tries to create other objects in your
patch.</p>
<p>For more details on how [declare] works, please check its help file!</p>
<h3 id="load-via-path-and-startup">Load via Path and Startup:</h3>
<p>We&rsquo;ll now see the differeces between using [declare] or using
&ldquo;Path&rdquo; and &ldquo;Startup&rdquo;.</p>
<h3 id="user-added-path">User added Path:</h3>
<p>One big difference in adding a search path in &ldquo;Preferences =&gt; Path&rdquo;
&ldquo;is that this permanently adds the path and work every time Pd starts
and for any patch you open. When you use [declare], the path is loaded
only for its owning patch and loaded abstractions. Moreover, if you have
an abstraction with [declare -path], it&rsquo;ll only work for that
abstraction and not the parent patch. Hence, [declare] allows a much
better control and management of paths. But you may want to permanently
add a path in your own system if you know exactly what you have and what
you need.</p>
<p>We&rsquo;ve seen that even if you have a folder in
&ldquo;<code>~/Documents/Pd/externals</code>&rdquo; you still need to tell Pd to look for it.
You can manually add a User Added Paths in Preferences =&gt; Path by
clicking &ldquo;New&rdquo;.</p>
<p>Another possibility is that under deken&rsquo;s preferences tabs you can click
on &ldquo;Add newly installed libraries to Pd&rsquo;s search Path&rdquo;, which adds
downloaded libraries to the user added search paths.</p>
<p>Note also that having a user added search path will not make it have
search priority like it happens when you use [declare]. In this case,
the path relative to the patch will always have top priority!</p>
<h3 id="startup">Startup:</h3>
<p>&ldquo;Preferences =&gt; Startup&rdquo; loads a window that says <em>&ldquo;Pd libraries to
load on startup&rdquo;</em>. This is where you can manually and permanently load
single binary pack libraries. But since they&rsquo;re only needed during
startup, you need to restart Pd so this takes effect. The startup is
also used for configuring Pd in many ways, see <a href="getting-pd-to-run.html#preferences-and-startup-options">Preferences and
startup options</a> for reference.</p>
<p><img src="x/img/fig4.5.png" alt=""></p>
<p>As we&rsquo;ve seen with &lsquo;zexy&rsquo;, it&rsquo;s common that the name of the binary is
the same as the library&rsquo;s, so you don&rsquo;t need to worry about adding it to
the path. Another example is the &lsquo;cyclone&rsquo; library. As previously
mentioned, Cyclone includes objects as abstractions, as a <strong>set of
separate binaries</strong> and also has a set a <strong>single binary
pack</strong> (which loads objects with non alphanumeric names that
need to be loaded as such to avoid issues). One particularity of cyclone
is that loading its binary will also force Pd to add its path to the
search paths, so you don&rsquo;t need to bother adding it to the path as well
in order to be able to load its abstractions or separate binaries.
Another example that uses this feature is
<a href="https://github.com/umlaeute/Gem">Gem</a> , which loads as a binary pack
but also includes a few abstractions that rely on the path search. Note,
however, that unlike using [declare], this does not enforce a search
priority! Hence, for example, you may prefer to use [declare -path
cyclone -lib cyclone] instead.</p>
<p>It all depends on the developer, but it is a common and good practice
that when you load a library, Pd&rsquo;s terminal window will print something
to tell us that the libraries were loaded successfully. Here&rsquo;s a
screenshot of the result of loading cyclone and zexy via the startup
(same happens if you load them via [declare], clearly).</p>
<p>Note that when you load a library like this or via [declare -lib], all
of its external objects are loaded in Pd and they have search priority.
This may cause issues discussed on the next section.</p>
<p><img src="x/img/fig4.6.png" alt=""></p>
<h3 id="slash-declarations">Slash declarations:</h3>
<p>What is this and how does it work? Let&rsquo;s say you&rsquo;ve downloaded the ELSE
library into <code>~/Documents/Pd/externals</code>. Instead of using [declare -path
else] or adding the ELSE folder to the user added paths manually, you
can just prepend &ldquo;else/&rdquo; before an object name. This will make Pd look
for this object in a folder called &rsquo;else&rsquo; in one of its search paths
(which includes <code>~/Documents/Pd/externals</code>) and find it! Here&rsquo;s an
example:</p>
<p><img src="x/img/fig4.7.png" alt=""></p>
<p>Now, what&rsquo;s the need or advantage of this over using [declare] or
adding the folder to the user added paths? This can be an option that
some people may prefer for the simple fact that it&rsquo;s just clearer from
which library folder we&rsquo;re loading the external. But there are some
rare cases where this is the only way to guarantee you have loaded the
correct external, which is a problem when you have too many libraries in
your system and are using more than one that has an external with the same
name. Hence, some external libraries like &lsquo;Cyclone&rsquo; and &lsquo;ELSE&rsquo; use
this in the documentation of the help files to make sure you load the
correct external.</p>
<p>Note, however, that this is not possible for an external that is loaded
as part of a single binary pack, unless the developer uses a workaround
to add this possibility as alternative.</p>
<p>The issue with [declare] or adding a path to the user added paths is
that it&rsquo;ll respect a search order. Whatever path is added first in the
search list order has a priority, and where ever Pd finds an external
first, it&rsquo;ll load it and stop searching elsewhere. Again, this kind of
problem is not that common, but you may be able to sort this issue by
setting the desired order. This is quite easy in [declare], which ever
-path comes first in the list has a priority. You can try this if you
want to avoid slash declarations when you run into this rare issue.</p>
<p>Such conflicts can also happen when you&rsquo;re loading single binary pack
libraries. The problem is that once they get loaded, all of its external
objects are now part of Pd and have a priority in the search. Here&rsquo;s an
example, the &lsquo;ceammc&rsquo; library is a single binary pack and it included
an object called [xfade~]. The ELSE library has separate binaries for
each object and also has one called [xfade~]. If you&rsquo;re using both
libraries, ceammc&rsquo;s [xfade~] object will have priority and it
doesn&rsquo;t help you to have [declare -path else]. You can then use
[else/xfade~] to specifically call ELSE&rsquo;s [xfade~] instead.</p>
<p>It was mentioned how a library name prefix may also be possible in the
context of single binary packs. The ceammc library offers this, so you
can also load its [xfade~] object as [ceammc/xfade~]. But note
that this still requires you to preload the binary (via startup or
[declare]). The slash declaration here was only possible because the
developer added the &lsquo;ceammc/xfade~&rsquo; name as an alternative option in
the code. So it is just a hack to improve the limitation of Pd in
handling namespaces. Another library that does this is Cyclone, which
carries a sublibrary with 12 objects with non alphanumeric names, such
as [&gt;~]. By using the same trick, you can create the [&gt;~] object
as [cyclone/&gt;~]. Another single binary pack library that has
[&gt;~] is zexy, so this way you can make sure you&rsquo;re getting
cyclone&rsquo;s instead.</p>
<p>These issues might be clear if you better understand how Pd works when
loading externals. See next subsection.</p>
<h3 id="how-external-binaries-are-loaded">How external binaries are loaded</h3>
<p>Once you make sure Pd can load an external binary, this is what happens
when you create it. Whenever you type the name of an object (into an
&ldquo;object&rdquo; box) that Pd doesn&rsquo;t yet know about, Pd looks for the object
file named, for instance, as &ldquo;profile.pd_linux&rdquo;. Pd looks first in a
path defined by [declare] (if any, of course), then in the directory
containing the patch, then in directories listed as user added paths in
the orderr they are listed, then in the standard paths. As soon as Pd
finds the object in this search order, it&rsquo;ll stop searching further
more and will add the found object to its &ldquo;class list&rdquo;, which is the
set of all Pd classes you can use. Pd then tries to create the object
you asked for, and if everything is fine with it, this happens
successfully (creation errors are given otherwise). In the case of a
single binary pack, all the externals it contains get preloaded in Pd,
even though they&rsquo;re only created in object boxes when you require them.</p>
<p>Once an external object&rsquo;s binary is in Pd&rsquo;s memory, there is no real
difference between it and a native object. They&rsquo;re all seen equally now
in Pd. Once a new separate binary or single binary pack is loaded, it&rsquo;s
there for the duration of your Pd session. This means that if you
replace the binaries, the objects won&rsquo;t be updated even if you recreate
them. You can also even delete the binary as Pd now carried it for good.
Hence, if you&rsquo;re working on the development of an object&rsquo;s binary and
decide to change it, you have to exit and re-enter Pd to get the change
to take.</p>
<p>Let us just make the distinction that external abstractions work quite
differently! As they get updated any time they&rsquo;re updated and reloaded!</p>
<h3 id="overriding-objects-externals-and-native">Overriding objects (externals and native):</h3>
<p>We&rsquo;ve seen that Pd loads and sticks to an external. But this can get
overridden. We&rsquo;ve actually seen that already. For instance, you create
[xfade~] from ELSE, then you load ceammc&rsquo;s binary that also has an
[xfade~] object. Now Pd only knows about [xfade~] from ceammc!
It&rsquo;s been also noted how cyclone and zexy have objects with the same
name. If you first load cyclone&rsquo;s binary and zexy&rsquo;s later, zexy&rsquo;s
objects with the same name (such as [&gt;~]) will override and prevail.</p>
<p>And here&rsquo;s an interesting feature, you can also override internal Pd
Vanilla objects with externals! Say you have an external called
[phasor~]. If it&rsquo;s a single binary, you can force Pd to find it with
slash declarations. Otherwise, if it&rsquo;s a binary pack, you can load as
any other library and if it has objects with the same name as vanilla&rsquo;s
internals, they get overridden! But Pd still keeps a copy of the old one
and renames it by appending &ldquo;_aliased&rdquo;, so you can still load the old
&ldquo;phasor~&rdquo;, for instance, as <strong>[phasor~_aliased]</strong>. You probably
don&rsquo;t want to mess with overriding internals, but it makes sense if you
provide new versions with more features but fully backwards compatible.</p>
<h3 id="search-order-for-loading-objects">Search order for loading objects</h3>
<p>This information has been provided in pieces throughout this section of
the Manual. But now well wrap it up after all the information has been
presented.</p>
<p>So, whenever you tell Pd to create an object in its box, this is what
happens.</p>
<p><strong>First</strong> it searches in its object list. This includes all of Pd&rsquo;s
internals and other externals that may have been previously loaded.</p>
<p><strong>Second</strong>, it moves on to possible paths. And if you have [declare
-path] in your patch, the defined path(s) has/have priority respecting
the order they are listed from left to right.</p>
<p><strong>Third</strong> is time to search the path relative to the patch.</p>
<p><strong>Fourth</strong> it goes to the user added paths, defined at &ldquo;Preferences =&gt;
Path&rdquo;. An order is also respected, from top to bottom.</p>
<p><strong>Fifth</strong> and last, it searches the &ldquo;standard paths&rdquo;, which includes
the &rsquo;extra&rsquo; library provided by the Pd Vanilla distribution. Note you
can use [declare -stdpath ./] to force priority to search this folder!</p>
<p><a href="current-status.html#">next chapter</a> <br>
<a href="index.html">back to table of contents</a></p>
</main>
    </div>
  </body>
</html>
