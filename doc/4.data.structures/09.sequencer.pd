#N struct template-event float x float y float color array pitch template-pitch array amp template-amp;
#N struct template-pitch float x float y float w;
#N struct template-amp float x float y float w;
#N canvas 237 49 531 432 12;
#X declare -stdpath ./;
#N canvas 368 112 453 283 template-event 0;
#X obj 38 196 plot pitch color 3 10 0;
#X obj 38 223 plot amp 0 3 10 0;
#X obj 38 156 filledpolygon 9 9 0 0 -2 0 2 5 2 5 -2;
#X obj 38 76 struct template-event float x float y float color array pitch template-pitch array amp template-amp, f 52;
#X text 25 22 Template contains x/y coordinates \, a color field for the pitch's array color and two arrays (pitch and amp)., f 57;
#X text 41 132 draw a small blue rectangle;
#X text 210 196 plot the pitch array;
#X text 170 222 plot the amp array;
#X restore 51 274 pd template-event;
#N canvas 416 229 394 148 template-amp 0;
#X obj 46 70 struct template-amp float x float y float w;
#X text 44 33 template for the element of the 'amp' array;
#X restore 51 298 pd template-amp;
#N canvas 434 368 414 98 template-pitch 0;
#X obj 40 55 struct template-pitch float x float y float w;
#X text 37 24 template for the element of the 'pitch' array;
#X restore 51 322 pd template-pitch;
#X floatatom 322 266 4 0 0 1 tempo tempo-set - 16;
#X msg 262 234 start;
#X msg 273 267 stop;
#N canvas 809 56 413 438 data 1;
#X scalar template-event 12 66.5 900 \; 0 0 12 \; 10 0 12 \; \; 0 0 0 \; 10 0 2.5 \; 11 0 0 \; \;;
#X scalar template-event 23 60.5 990 \; 0 0 12 \; 10 0 12 \; \; 0 0 2.5 \; 10 0 2.5 \; 11 0 0 \; \;;
#X scalar template-event 47 23.75 90 \; 0 65 12 \; 100 10 0 \; 100 10 12 \; 230 50 0 \; 230 10 3 \; 240 60 0 \; 240 25 10 \; 250 60 0 \; 250 37 10 \; 260 65 0.5 \; 285 65 0.5 \; \; 1 0 2 \; 103 0 1 \; 195 0 2 \; 220 0 0.75 \; 225 0 1.25 \; 248 0 2.5 \; 251 0 2.25 \; 255 0 0 \; 256 0 1.5 \; 260 0 0 \; 261 0 2 \; 265 0 0 \; 266 0 2.5 \; 270 0 0 \; 271 0 3 \; 275 0 0 \; \;;
#X scalar template-event 83 58 900 \; 0 5 0.25 \; 60 5 0.25 \; \; 0 0 0 \; 28 -0.25 3.5 \; 58 -0.25 0 \; \;;
#X scalar template-event 151 85.5 900 \; 0 0 12 \; 70 -20 12 \; \; 0 0 0 \; 10 0 2.5 \; 20 0 0 \; 30 0 0 \; 40 0 2.5 \; 50 0 0 \; 60 0 2.5 \; 70 0 0 \; \;;
#X scalar template-event 328 44 909 \; 0 0 12 \; 50 0 12 \; \; 0 0 4 \; 10 0 2.5 \; 50 0 0 \; \;;
#X coords 0 109.5 1 109.25 0 0 0;
#X restore 415 339 pd data;
#N canvas 553 421 419 177 stuff 0;
#X msg 41 50 \; pd-data read event.txt;
#X obj 248 39 loadbang;
#X msg 41 94 \; pd-data write event.txt;
#X obj 240 126 declare -stdpath ./;
#X msg 248 66 \; tempo-set 50;
#X connect 1 0 4 0;
#X restore 408 365 pd stuff;
#X text 48 28 This patch shows an example of how to use data collections as musical sequences (with apologies to Yuasa and Stockhausen). Here the black traces show dynamics and the colored ones show pitch. The fatness of the pitch traces give bandwidth. Any of the three can change over the life of the event., f 61;
#X obj 262 344 output~;
#X text 53 251 templates:;
#X text 48 147 Note the screen units in the "data" window is 0.25 (ask for "properties" to see them) \, meaning that adding one to a 'y' values in arrays moves it up four pixels. In other words \, this stretches the vertical display of the scalar objects., f 61;
#X text 48 109 To hear the result \, turn the volume and hit "start". You can set the tempo lower if that helps you follow the "events"., f 61;
#N canvas 433 51 566 526 guts 0;
#X msg 86 289 traverse pd-data \, next;
#X obj 86 142 inlet;
#X obj 86 182 route start stop;
#X obj 86 450 outlet~;
#X obj 334 285 s delay-multiplier;
#X obj 86 380 clone 4 voice;
#X obj 86 228 t b b;
#X obj 334 213 expr 1000 / $f1;
#X obj 334 142 inlet;
#X text 380 141 tempo;
#X floatatom 334 250 6 0 0 0 - - - 0;
#X floatatom 334 178 5 0 0 0 - - - 0;
#N canvas 542 74 488 534 voice-routing 0;
#X msg 162 165 next;
#X msg 126 133 traverse pd-data \, next;
#X obj 126 195 pointer;
#X obj 126 267 get template-event color;
#N canvas 68 97 265 165 red 0;
#X obj 90 56 inlet;
#X obj 90 94 print red;
#X connect 0 0 1 0;
#X restore 161 454 pd red;
#N canvas 662 320 276 195 yellow 0;
#X obj 100 66 inlet;
#X obj 100 104 print yellow;
#X connect 0 0 1 0;
#X restore 195 425 pd yellow;
#N canvas 360 146 228 194 green 0;
#X obj 78 37 inlet;
#X obj 78 81 print green;
#X connect 0 0 1 0;
#X restore 229 396 pd green;
#N canvas 357 186 312 198 purple 0;
#X obj 98 33 inlet;
#X obj 98 78 print purple;
#X connect 0 0 1 0;
#X restore 263 370 pd purple;
#X obj 161 340 route 900 990 90 909;
#X obj 126 229 trigger pointer pointer, f 27;
#X obj 161 305 pack float pointer, f 22;
#X text 41 24 This example shows how one can use a different approach to route scalars to a specific voice subpatch depending on the color of the pitch array. Alternativelly \, inside a cloned abstraction \, one could use the color parameter to choose a different noise input or something., f 57;
#X connect 0 0 2 0;
#X connect 1 0 2 0;
#X connect 2 0 9 0;
#X connect 3 0 10 0;
#X connect 8 0 4 0;
#X connect 8 1 5 0;
#X connect 8 2 6 0;
#X connect 8 3 7 0;
#X connect 9 0 3 0;
#X connect 9 1 10 1;
#X connect 10 0 8 0;
#X restore 392 456 pd voice-routing;
#N canvas 209 70 586 628 sequence 0;
#X obj 136 189 inlet;
#X obj 297 397 *;
#X obj 308 574 outlet;
#X obj 227 422 pointer;
#X obj 297 367 -;
#X obj 331 369 r delay-multiplier;
#X obj 227 376 delay;
#X obj 315 257 get template-event x y;
#X msg 364 325 0;
#X obj 136 261 trigger bang pointer;
#X msg 58 236 next;
#X obj 136 221 pointer;
#X obj 227 455 t b p;
#X obj 308 444 pack pointer float, f 23;
#X text 321 472 pointer (delayed) and y-value;
#X obj 308 505 list prepend next;
#X obj 308 529 list trim;
#X obj 315 289 t f f;
#X floatatom 331 397 9 0 0 0 - - - 0;
#X msg 227 341 stop;
#X obj 364 297 r reset;
#X text 21 108 When [delay] sends a bang \, the pointer is packed with the pitch information and a 'next' selector is prepended for the [clone] object in the parent window. We then ask for the next event \, which calls the next pointer in the sequence., f 76;
#X text 21 16 Here we carry out the actual sequencing. We get a pointer to the scalar and get its x/y coordinates. The y-value is treated as a base pitch value (and is summed to the y-values of the pitch array inside [clone]). The x-value is taken as a time stamp - so we get the time difference from it and the last event \, multiply it by a "delay-multiplier" value that depends on the "tempo" parameter and send this to a [delay] object., f 76;
#X text 396 527 prepend 'next' for [clone], f 14;
#X connect 0 0 11 0;
#X connect 1 0 6 1;
#X connect 3 0 12 0;
#X connect 4 0 1 0;
#X connect 5 0 1 1;
#X connect 5 0 18 0;
#X connect 6 0 3 0;
#X connect 7 0 17 0;
#X connect 7 1 13 1;
#X connect 8 0 4 1;
#X connect 9 0 6 0;
#X connect 9 1 3 1;
#X connect 9 1 7 0;
#X connect 10 0 11 0;
#X connect 11 0 9 0;
#X connect 12 0 10 0;
#X connect 12 1 13 0;
#X connect 13 0 15 0;
#X connect 15 0 16 0;
#X connect 16 0 2 0;
#X connect 17 0 4 1;
#X connect 17 1 4 0;
#X connect 19 0 6 0;
#X connect 20 0 8 0;
#X connect 20 0 19 0;
#X restore 86 333 pd sequence;
#X text 98 404 (synthesis);
#X msg 140 215 \; reset bang \; pd-data sort;
#X text 289 326 Here we have a single patch for all voices \, so they're all playing the same "instrument". The color parameter on the event is not used \, but one could use it to route to a specific instrument/abstraction. Check the subpatch below for ideas:, f 32;
#X text 34 20 We start by traversing the [pd data] window and getting the pointer for the first scalar. This is done in [pd sequencer] \, open it] for details on how the sequencing is implemented. The [pd sequencer] sends a pointer and pitch base value to [clone] \, which loads 4 copies of the [voice] abstraction. The actual synthesis and sequencing is taken care inside [voice] \, open [clone] for more details., f 72;
#X connect 0 0 13 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 2 1 15 0;
#X connect 5 0 3 0;
#X connect 6 0 0 0;
#X connect 6 1 15 0;
#X connect 7 0 10 0;
#X connect 8 0 11 0;
#X connect 10 0 4 0;
#X connect 11 0 7 0;
#X connect 13 0 5 0;
#X restore 262 306 pd guts;
#X f 9;
#X text 308 233 (or restart);
#X text 23 372 Updated for Pd version 0.55-0;
#X connect 3 0 13 1;
#X connect 4 0 13 0;
#X connect 5 0 13 0;
#X connect 13 0 9 0;
