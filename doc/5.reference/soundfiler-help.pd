#N canvas 206 180 1042 654 12;
#X obj 60 320 soundfiler;
#X floatatom 60 349 7 0 0 0 - - - 12;
#X obj 391 608 tabwrite~;
#X obj 465 608 tabread4~;
#X obj 538 608 tabplay~;
#X obj 324 608 writesf~;
#X obj 266 608 readsf~;
#X text 34 609 See also:;
#X text 256 156 read a file to zero or more arrays, f 35;
#X obj 40 15 soundfiler;
#X obj 215 608 array;
#X listbox 127 349 16 0 0 0 - - - 0;
#X obj 6 49 cnv 1 1025 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 916 14 <= click;
#N canvas 540 87 632 371 reference 0;
#X obj 8 52 cnv 5 610 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X obj 8 182 cnv 2 610 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000 0;
#X obj 8 301 cnv 2 610 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 7 335 cnv 5 610 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 7 247 cnv 1 610 1 empty empty 2nd: 8 12 0 13 #7c7c7c #000000 0;
#X obj 7 210 cnv 1 610 1 empty empty 1st: 8 12 0 13 #7c7c7c #000000 0;
#X text 109 254 list -;
#X text 102 219 float - number of samples (when reading a file)., f 58;
#X text 75 66 read <list> -;
#X text 174 66 sets a filename to open and optionally one or more arrays to load channels. Optional flags: -wave \, -aiff \, -caf \, -next \, -skip <float> \, -maxsize <float> \, -ascii \, -raw <list>.;
#X text 68 117 write <list> -;
#X obj 30 15 soundfiler;
#X text 234 309 NONE;
#X text 174 116 sets a filename to write and one or more arrays to specify channels. Optional flags: -wave \, -aiff \, -caf \, -ascii \, -next \, -big \, -little \, -skip <float> \, -nframes <float> \, -normalize \, -rate <float>.;
#X text 157 254 sample rate \, header size \, number of channels \, bytes per sample & endianness ('b' or 'l')., f 51;
#X text 112 15 - import/export sound or ascii files to/from arrays.;
#X restore 822 15 pd reference;
#X msg 34 156 read ../sound/bell.aiff sample;
#X msg 60 191 read -resize ../sound/bell.aiff sample;
#X text 340 184 optionally resize array to fit the whole file, f 23;
#X text 28 127 Basic read/write example:;
#N canvas 762 180 575 345 Dealing_with_"\$0" 0;
#X obj 273 171 array define \$0-x;
#X obj 153 202 f \$0;
#X obj 153 263 soundfiler;
#X floatatom 153 289 7 0 0 0 - - - 0;
#X msg 153 231 read -resize ../sound/bell.aiff \$1-x;
#X obj 153 176 loadbang;
#X text 405 172 <- array with local name, f 13;
#X text 36 33 '\$0' - the patch ID number used to force locality in Pd - is widely used in send/receive names as well as array names. This is especially useful in abstractions so each copy has local names instead of global., f 70;
#X text 36 86 Here we use "\$0" in an array name in [array define] and if you need to set the array name in a message you can load '\$0' in a float object and send it to it., f 70;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 4 0 2 0;
#X connect 5 0 1 0;
#X restore 747 392 pd Dealing_with_"\$0";
#X text 577 255 Note that if no array name is given to read to \, no samples are read but you get the number of samples in the file on the left outlet and the info on the right outlet anyway., f 62;
#X text 577 443 Both 'read' and 'write' messages also take optional flags for configuration. In the basic example to the left we have the '-resize' flag in the read message that resizes the array to the file size. See more about flags and advanced examples in the subpatch below., f 62;
#X obj 6 576 cnv 1 1025 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X obj 606 608 openpanel;
#X obj 679 608 savepanel;
#X text 44 369 # samples;
#X text 86 243 write to a file;
#X text 124 369 info: sample rate \, header size \, channels \, bytes \, endianness;
#X obj 285 248 cnv 19 248 98 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 22 450 300 (subpatch) 0;
#X array sample 88200 float 2;
#X coords 0 1 88200 -1 250 100 1 0 0;
#X restore 284 247 graph;
#X text 28 61 The [soundfiler] object loads files into arrays and also saves arrays into files. The soundfiles may contain uncompressed 2- or 3-byte integer ("pcm") or 4- or 8-byte floating point samples in wave \, aiff \, caf and next formats. Also \, [soundfiler] deals with ascii text files., f 72;
#X text 577 312 Also note that the number of channels is limited to 64 for both reading and writing., f 62;
#X text 580 365 Open subpatch to see how to deal with '\$0';
#X text 799 602 updated for Pd version 0.55-0;
#X text 29 396 A 'read' message takes a filename and one or more arrays to load it into (when the file has more than one channel). The number of channels of the soundfile need not match the number of arrays given to read (extras channels are dropped and unsupplied channels are zeroed out in the extra arrays). The 'write' message takes a filename to save to and one or more arrays (one for each channel). Note that both 'read' and 'write' messages can expand "~" to the home directory., f 73;
#X text 29 499 Also note: Loading a soundfile into an array might be useful for more flexible playing strategies with table reading objects in the 'see section' below. For a simpler alternative that streams a soundfile directly from your hard drive \, see [readsf~]., f 73;
#X msg 83 271 write ~/test.wav sample;
#X text 577 74 At loading or writting a file \, the left outlet outputs the number of samples and the right outlet sends information as a list \, namely: Sample Rate \, Header Size \, Number of Channels \, Bytes per Sample and Endianness ("b" for "big" or "l" for "little")., f 62;
#N canvas 189 207 1235 596 read-write-flags 0;
#X obj 629 464 soundfiler;
#X text 27 15 Flags for 'read' message:, f 73;
#X text 18 417 Flags for 'write' message:, f 69;
#X text 48 117 [soundfiler] can figure out which of the known soundfile formats the file belongs to or override all header and type information using the "-raw" flag \, which causes all header and type information to be ignored. Endianness is "l" ("little") for Intel machines or "b" ("big") for older PPC Macintoshes. You can give "n" (natural) to take the byte order your machine prefers., f 70;
#X text 27 204 -ascii (read a file containing ascii numbers), f 73;
#X text 48 221 This may only be combined with '-resize'. Newlines in the file are ignored \, non-numeric fields are replaced by zero. If multiple arrays are specified \, the first elements of each array should come first in the file \, followed by all the second elements and so on (interleaved)., f 70;
#X text 27 32 -wave \, -aiff \, -caf \, -next (soundfile format), f 73;
#X text 891 169 read from an ascii file;
#X listbox 696 522 17 0 0 0 - - - 0;
#X msg 612 138 read -resize -raw 128 2 2 b ../sound/bell.aiff array1 array2;
#X msg 638 192 read -ascii -resize table.txt array1 array2;
#X floatatom 629 522 6 0 0 0 - - - 0;
#X obj 573 58 openpanel;
#X obj 573 23 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 657 301 savepanel;
#X obj 657 266 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X text 18 522 -rate <float> (sample rate \, default Pd's running sample rate), f 71;
#X text 18 468 -skip <float> (number of points to skip in array \, default 0), f 69;
#X text 27 49 -skip <float> (sample frames to skip in the file as an offset), f 73;
#X text 27 100 -raw <f \, f \, f \, s> (header size \, channels \, bytes per sample \, endianness), f 73;
#X text 18 434 -wave \, -aiff \, -caf \, -next \, -ascii (soundfile format \, default: 'wave'), f 69;
#X text 18 451 -big \, -little (sample endianness \, default 'little'), f 69;
#X msg 657 329 write \$1 array1 array2;
#X msg 573 86 read -resize \$1 array1 array2;
#X msg 594 113 read -maxsize 44100 -aiff ../sound/bell.aiff array1 array2;
#X text 833 89 set max size and extension;
#X msg 629 169 read -ascii -resize table.txt array1;
#N canvas 683 221 473 479 more-writting-examples 0;
#X obj 41 442 outlet;
#X text 148 166 write a mono file and set number of samples, f 22;
#X obj 69 177 savepanel;
#X obj 69 142 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 41 69 savepanel;
#X obj 41 34 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 99 278 bng 23 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X text 120 29 Write a stereo file with a 2 byte resolution and in the 'next' format (so when typing into the savepannel dialog you should not set the file extension), f 47;
#X msg 41 104 write -next -bytes 2 \$1 array1 array2;
#X obj 99 319 savepanel;
#X text 130 273 write to an ascii file (you don't set the file extension to '.txt' because of the ascii flag), f 46;
#X msg 99 355 write -nframes 3 -skip 2 -ascii \$1 array1;
#X msg 69 212 write -skip 22050 -nframes 44100 \$1 array1;
#X connect 2 0 12 0;
#X connect 3 0 2 0;
#X connect 4 0 8 0;
#X connect 5 0 4 0;
#X connect 6 0 9 0;
#X connect 8 0 0 0;
#X connect 9 0 11 0;
#X connect 11 0 0 0;
#X connect 12 0 0 0;
#X restore 663 384 pd more-writting-examples;
#X text 683 268 Write a stereo fie;
#X text 605 24 Choose file to save to or read from in your hard disk;
#X obj 863 249 cnv 19 323 118 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#X obj 863 393 cnv 19 323 118 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 22 450 300 (subpatch) 0;
#X array array1 78003 float 2;
#X coords 0 1 78003 -1 325 120 1 0 0;
#X restore 862 248 graph;
#N canvas 0 22 450 300 (subpatch) 0;
#X array array2 78003 float 2;
#X coords 0 1 78003 -1 325 120 1 0 0;
#X restore 862 392 graph;
#N canvas 460 493 480 224 8-byte 0;
#X text 19 62 The precision of the 8-byte samples is based on the precision of the Pure Data build. If Pd is single precision (using 32-bit float internally) \, the written samples will be cast from 4-byte float to 8-byte double when writing to a file with -bytes 8 argument. In this case it's better to write with 4-byte float samples for a smaller file with the same precision., f 63;
#X text 19 159 if Pd is double-precision \, writing 8-byte float samples will be full precision as Pd uses 64-bit float internally., f 63;
#X text 19 19 Writing 8-byte (ie. 64-bit) floating point samples are supported for the .wave \, .aiff/.aifc and .caf file types.;
#X restore 440 503 pd 8-byte float;
#X text 18 540 -normalize (normalize file to '1' \, note that arrays whose values exceed the -1 to 1 range are automatically normalized), f 71;
#X text 611 547 # samples;
#X text 696 548 info: sample rate \, header size \, channels \, bytes \, endianness;
#X text 27 83 -maxsize <float> (maximum number of samples to resize to *), f 73;
#X text 27 66 -resize (resizes arrays to the size of the sound file *), f 73;
#X text 1043 131 read overriding the file's header, f 17;
#X text 17 288 * When loading a file \, [soundfiler] populates the array until reaching its size. If the sound file is smaller \, the remaining points are zeroed out. The -resize flag resizes the array to the sample size \, while the -maxsize flag sets a maximum size to clip to even if used in conjunction with the '-resize' flag (also \, errors are given to warn you about the truncation). The -maxsize was needed for historical reasons when its default value used to be rather small (4 million). The default now is much bigger \, hence \, this flag can just be ignored., f 78;
#X text 18 485 -nframes <float> (maximum points to write \, default from skip point to end of array), f 83;
#X text 18 503 -bytes <float> (bytes per sample: 2 \, 3 \, 4 \, or 8 default: 2);
#X connect 0 0 11 0;
#X connect 0 1 8 0;
#X connect 9 0 0 0;
#X connect 10 0 0 0;
#X connect 12 0 23 0;
#X connect 13 0 12 0;
#X connect 14 0 22 0;
#X connect 15 0 14 0;
#X connect 22 0 0 0;
#X connect 23 0 0 0;
#X connect 24 0 0 0;
#X connect 26 0 0 0;
#X connect 27 0 0 0;
#X restore 784 529 pd read-write-flags;
#X text 577 157 When loading a file \, the left outlet sends the number of samples the file contains if the array is equal or greater in size. If you're loading a file that is bigger than the array size \, the number or samples gets clipped to the array size (you probably want to use the -resize flag in this case to automatically resize the array size to the file size)., f 62;
#X text 120 13 - import/export sound or ascii files to/from arrays;
#N canvas 0 22 450 278 (subpatch) 0;
#X array array_x 10 float 3;
#A 0 0 0 0 0 0 0 0 0 0 0;
#X coords 0 1 10 -1 90 40 1 0 0;
#X restore 116 598 graph;
#X connect 0 0 1 0;
#X connect 0 1 11 0;
#X connect 15 0 0 0;
#X connect 16 0 0 0;
#X connect 36 0 0 0;
