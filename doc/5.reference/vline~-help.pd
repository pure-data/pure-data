#N canvas 469 51 616 763 12;
#X obj 114 617 snapshot~;
#X floatatom 114 647 8 0 0 0 - - - 0;
#X msg 143 489 stop;
#X msg 114 376 0;
#X text 19 726 see also:;
#X obj 95 727 line;
#X obj 141 727 line~;
#X obj 27 15 vline~;
#X text 84 15 - high-precision audio ramp generator;
#X obj 114 582 vline~;
#X text 127 326 ramp up;
#X msg 96 350 0 1000;
#X text 149 351 ramp down;
#X text 147 375 jump down;
#X text 402 726 updated for Pd version 0.47;
#X floatatom 153 555 5 0 0 0 - - - 0;
#X floatatom 149 521 5 0 0 0 - - - 0;
#X text 195 551 right inlet sets next delay time (cleared when ramp starts!), f 32;
#X obj 11 44 cnv 1 600 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 526 14 <= click;
#N canvas 708 145 583 306 reference 0;
#X obj 9 42 cnv 5 550 5 empty empty INLETS: 8 18 0 13 #202020 #000000 0;
#X obj 9 205 cnv 2 550 2 empty empty OUTLET: 8 12 0 13 #202020 #000000 0;
#X obj 9 239 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 8 276 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 9 75 cnv 1 550 1 empty empty 1st: 8 12 0 13 #9f9f9f #000000 0;
#X text 133 80 float - set target value and start ramp.;
#X obj 9 127 cnv 1 550 1 empty empty 2nd: 8 12 0 13 #9f9f9f #000000 0;
#X text 133 136 float - set next ramp time (cleared when ramp starts).;
#X text 126 214 signal - ramp values.;
#X text 189 249 NONE;
#X obj 27 15 vline~;
#X text 91 15 - high-precision audio ramp generator;
#X obj 9 164 cnv 1 550 1 empty empty 3rd: 8 12 0 13 #9f9f9f #000000 0;
#X text 141 99 stop - stops the ramp.;
#X text 133 173 float - sets delay time.;
#X restore 432 14 pd reference;
#X obj 10 710 cnv 1 600 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 184 488 "stop" message freezes [vline~] at its current value;
#X msg 466 352 \; pd dsp \$1;
#X obj 466 317 set-dsp-tgl;
#X text 497 321 DSP on/off;
#X obj 192 727 sig~;
#X text 25 164 Like [line~] \, note that the middle and right inlet (that sets the time and delay) get cleared after the ramp starts (this is unlike other inlets in Pd). Thus \, if you resend [vline~] a float without priorly resetting a ramp time and delay \, it jumps immediately to the target value. A list up to three floats distributes the values over the inlets \, as usual in Pd., f 80;
#X text 25 243 Any number of future ramps may be scheduled and [vline~] will remember them and execute them in order. You can do that by sending different lists in single messagebox. They must be specified in increasing order of initial delay however \, since a segment cancels all planned segments at any future time., f 80;
#X text 192 513 middle inlet sets next ramp time (cleared when ramp starts!), f 32;
#X text 290 614 Open subpacth for mores details and information, f 24;
#N canvas 505 109 896 726 details 0;
#X text 28 154 !!! BUG: [vline~] objects inside reblocked subpatches can have slightly incorrect timing !!!;
#N canvas 644 207 469 412 conversion 0;
#X obj 142 302 vline~;
#X obj 132 229 bng 20 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 239 241 random 100;
#X obj 239 297 sig~;
#X floatatom 239 269 5 0 0 0 - - - 0;
#X obj 239 335 print~ SIG;
#X obj 132 333 print~ VLINE;
#X obj 239 211 metro 1 1 samps;
#X obj 239 175 tgl 19 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000 0 1;
#X text 266 173 <-- start metronome, f 9;
#X text 60 230 click -->;
#X text 54 24 With immediate jumps (0 length lines) you can use [vline~] to sort of convert floats to signals with more precision than [sig~] \, by making transitions in the middle of a block \, and you can also convert more than one float to a signal within a block. In the example below we convert floats to signals for every sample. Note that [sig~] will only catch the value of the last received float and keep it., f 50;
#X connect 0 0 6 0;
#X connect 1 0 5 0;
#X connect 1 0 6 0;
#X connect 2 0 4 0;
#X connect 3 0 5 0;
#X connect 4 0 0 0;
#X connect 4 0 3 0;
#X connect 7 0 2 0;
#X connect 8 0 7 0;
#X restore 286 101 pd conversion;
#N canvas 728 131 507 450 impulse 0;
#X obj 308 337 vline~;
#X msg 340 229 1;
#X obj 341 274 delay 1 1 samp;
#X msg 341 302 0;
#X obj 290 374 print~;
#X obj 290 151 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 308 194 t b b;
#X obj 164 184 samplerate~;
#X floatatom 164 243 12 0 0 0 - - - 0;
#X obj 164 214 expr 1000/$f1;
#X obj 116 222 f;
#X obj 97 180 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X msg 117 292 1 \, 0 0 \$1;
#X obj 117 327 vline~;
#X obj 99 364 print~;
#X obj 164 157 loadbang;
#X text 50 16 The example below uses [vline~] to generate an impulse \, which is a single sample with a value of '1' followed by zeros again. We do this by having an immediate jump and then having another immediate jump back to zero delayed by a sample. On the left we use the delay schedule and calculate the delay of one sample in ms. On the right we use [delay] to delay the message by a sample externally., f 56;
#X connect 0 0 4 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 3 0 0 0;
#X connect 5 0 4 0;
#X connect 5 0 6 0;
#X connect 6 0 2 0;
#X connect 6 1 1 0;
#X connect 7 0 9 0;
#X connect 9 0 8 0;
#X connect 9 0 10 1;
#X connect 10 0 12 0;
#X connect 11 0 10 0;
#X connect 11 0 14 0;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X connect 15 0 7 0;
#X restore 286 41 pd impulse;
#X text 136 32 Example on how to generate an impulse, f 19;
#X text 52 87 Example on how to use [vline~] to convert floats to samples with more precision than [sig~], f 31;
#X obj 536 167 vline~;
#X obj 521 209 print~;
#X obj 521 100 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 613 443 vline~;
#X obj 565 483 print~;
#X obj 565 331 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 613 374 delay 1 1 samp;
#X msg 580 406 0;
#X msg 613 405 1 0.5 0 \, 0 0.5 0.5;
#X msg 536 131 0 \, 1 0.5 0;
#X text 634 104 Here we first have an immediate jump to 0 and start a new ramp from it to 1 in 0.5 ms., f 23;
#X text 634 166 Note that the ramp up doesn't start at 0 but at the 1st increment step., f 23;
#X obj 167 330 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 271 355 samplerate~;
#X floatatom 271 414 12 0 0 0 - - - 0;
#X obj 271 385 expr 1000/$f1;
#X obj 130 394 b;
#X obj 167 411 vline~;
#X obj 167 463 print~;
#X obj 167 375 pack f 10 f;
#X obj 271 328 loadbang;
#X text 261 439 one sample delay;
#X text 490 30 This is more problematic when you try to set a start point to a ramp \, like you can do with [line~]., f 45;
#X text 517 259 Below we deal with this situation by delaying the following ramps after the start point by one sample with [delay]., f 39;
#X obj 220 587 pack f 10;
#X obj 195 631 list;
#X obj 97 554 trigger bang float;
#X obj 97 584 delay 1 1 samp;
#X obj 97 521 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 195 674 vline~;
#X text 143 519 Another strategy is to use [delay];
#N canvas 799 303 452 511 sub-sample-accuracy 0;
#X obj 162 341 vline~;
#X obj 114 381 print~;
#X obj 114 287 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X msg 162 301 0 \, 64 1.45125 \, 0 0 1.45125;
#X text 73 32 Below we can compare a sub sample delay and see the effect on the output. The object is generating an integer increment ramp over the span of an audio block (considering a sample rate of 44.1Khz)., f 43;
#X msg 146 139 0;
#X msg 162 167 0.5;
#X msg 172 200 1;
#X text 204 158 Test different delay times, f 14;
#X floatatom 162 233 5 0 0 0 - - - 0;
#X obj 162 270 delay 1 1 samp;
#X text 106 433 We can see that a half sample delay interpolates the result., f 36;
#X connect 0 0 1 0;
#X connect 2 0 1 0;
#X connect 3 0 0 0;
#X connect 5 0 9 0;
#X connect 6 0 9 0;
#X connect 7 0 9 0;
#X connect 9 0 2 0;
#X connect 9 0 10 0;
#X connect 10 0 3 0;
#X restore 645 659 pd sub-sample-accuracy;
#X text 28 188 Another known issue: Unlike [line~] \, [vline~] immediately jumps to the first increment when triggered. This is a knowingly unfortunate design (aka bug) and probably ok for most cases. Since ramps are always one sample too short \, a line of 1 sample duration is the same as a 0 length (immediate jump). This may eventually be fixed \, but for the meantime you can add a one sample delay when starting a ramp \, if you really need it to start at the current value., f 57;
#X text 493 539 Sub-sample accuracy: In the above example \, we don't see our ramp reach the value of '1' \, which would be the end of the first ramp and the start of the next one. This is because this point lies in between samples and [vline~] has sub-sample accuracy \, in which it interpolates accordingly. Check another example below., f 51;
#X connect 5 0 6 0;
#X connect 7 0 6 0;
#X connect 7 0 14 0;
#X connect 8 0 9 0;
#X connect 10 0 12 0;
#X connect 10 0 9 0;
#X connect 10 0 11 0;
#X connect 11 0 13 0;
#X connect 12 0 8 0;
#X connect 13 0 8 0;
#X connect 14 0 5 0;
#X connect 17 0 21 0;
#X connect 17 0 24 0;
#X connect 18 0 20 0;
#X connect 20 0 19 0;
#X connect 20 0 24 2;
#X connect 21 0 23 0;
#X connect 22 0 23 0;
#X connect 24 0 22 0;
#X connect 25 0 18 0;
#X connect 29 0 30 1;
#X connect 30 0 34 0;
#X connect 31 0 32 0;
#X connect 31 1 29 0;
#X connect 32 0 30 0;
#X connect 33 0 31 0;
#X restore 472 621 pd details;
#X text 25 56 The [vline~] object generates linear ramps like [line~] \, but with more time resolution \, where amps may start and stop within blocks and even between audio samples (in which case the output is interpolated accordingly). It takes a target value \, a time interval in milliseconds to reach it and an initial delay (also in ms). This object can also convert float to signals with more preciosion than [sig~] (see [pd details] below). Unlike [line~] \, it starts incrementing right away (also see [pd details] below)., f 80;
#X msg 129 427 1 1000 \, 0 0 2000 \, 1 1000 3000 \, 0 0 4000;
#X obj 117 676 hsl 162 19 0 1 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 33 582 metro 10;
#X obj 33 555 loadbang;
#X msg 76 326 1 1000;
#X text 124 403 ramp up \, wait \, jump down \, wait \, ramp up again \, jump down again, f 62;
#X text 138 452 note: times (2000 \, 3000 \, 4000) are cumulative \, not incremental., f 63;
#X connect 0 0 1 0;
#X connect 1 0 34 0;
#X connect 2 0 9 0;
#X connect 3 0 9 0;
#X connect 9 0 0 0;
#X connect 11 0 9 0;
#X connect 15 0 9 2;
#X connect 16 0 9 1;
#X connect 24 0 23 0;
#X connect 33 0 9 0;
#X connect 35 0 0 0;
#X connect 36 0 35 0;
#X connect 37 0 9 0;
