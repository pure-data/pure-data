#N canvas 436 39 591 646 12;
#X floatatom 334 382 5 0 0 0 - - - 0;
#X obj 46 235 sig~ 50;
#X obj 334 352 snapshot~;
#X obj 334 303 metro 200;
#X obj 46 342 sig~ 25;
#X obj 166 609 tabsend~;
#X obj 98 42 s~;
#X obj 129 42 r~;
#X text 11 609 see also:;
#X obj 78 609 throw~;
#X text 162 41 - abbreviation;
#X obj 334 271 loadbang;
#X obj 440 218 tgl 19 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000 0 1;
#X msg 440 246 \; pd dsp \$1;
#X text 463 217 on/off;
#X floatatom 46 209 5 0 0 0 - - - 0;
#X floatatom 426 382 5 0 0 0 - - - 0;
#X obj 426 352 snapshot~;
#X obj 18 14 send~ x;
#X obj 78 14 receive~ x;
#X obj 46 262 send~ \$0-signal;
#X obj 46 370 send~ signal;
#X msg 198 283 set signal;
#X msg 186 256 set \$1-signal;
#X obj 186 232 f \$0;
#X obj 186 207 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X floatatom 46 315 5 0 0 0 - - - 0;
#N canvas 597 199 505 182 execution-order 0;
#X obj 114 123 ../3.audio.examples/G05.execution.order;
#X text 46 30 You have to get the [send~] sorted before the [receive~] or else you'll potentially get a one block delay. Although this is inevitable for feedback loops \, it should be mostly desired in other cases. You can use the strategy given in the example below to control this., f 61;
#X restore 341 546 pd execution-order;
#X obj 186 311 receive~ \$0-signal;
#N canvas 697 108 568 447 reference 0;
#X obj 8 53 cnv 5 550 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X obj 8 97 cnv 2 550 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000 0;
#X obj 6 138 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 8 185 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 8 321 cnv 2 550 2 empty empty OUTLET: 8 12 0 13 #202020 #000000 0;
#X obj 8 366 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 7 421 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X text 146 107 NONE;
#X obj 28 15 send~ y;
#X obj 24 245 receive~ y;
#X obj 8 281 cnv 5 550 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X text 109 294 set <name> - set receive name.;
#X text 139 67 signal - signal to send to matching receive~ object(s).;
#X text 138 332 signal - outputs signal from a matching send~ object.;
#X text 124 142 1) symbol - send symbol name (default: empty symbol).;
#X text 106 376 1) symbol - receive name symbol (default: empty symbol).;
#X text 113 394 2) float - number of channels (default: 1)., f 55;
#X text 131 162 2) float - number of channels (default: 1)., f 52;
#X text 89 15 - send signal(s) to one or more [receive~] objects.;
#X text 107 244 - receive signal(s) from a [send~] object.;
#X restore 485 42 pd reference;
#X obj 4 74 cnv 1 580 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 225 211 \$0 needs to be expanded from objects., f 23;
#X text 376 609 updated for Pd version 0.54;
#X obj 426 319 r~ signal;
#N canvas 587 172 505 347 multi-channel 0;
#X floatatom 65 45 5 0 0 0 - - - 0;
#X floatatom 139 45 5 0 0 0 - - - 0;
#X obj 71 279 snapshot~;
#X floatatom 71 305 8 0 0 0 - - - 0;
#X obj 152 279 snapshot~;
#X obj 174 241 metro 250;
#X obj 174 212 loadbang;
#X floatatom 152 305 8 0 0 0 - - - 0;
#X text 308 254 see also:;
#X obj 355 282 clone;
#X text 151 117 <-- 2nd argument sets number;
#X text 179 135 of channels to '2', f 24;
#X text 178 163 <-- 2nd argument sets number;
#X text 206 181 of channels to '2', f 24;
#X obj 65 117 send~ cat 2;
#X obj 71 163 receive~ cat 2;
#X obj 65 75 snake~ in 2;
#X obj 71 213 snake~ out 2;
#X obj 298 282 snake~;
#X text 182 23 This example shows how to set number of channels as the 2nd argument \, so it can take a multichannel signal as it's possible with [snake~] or [clone]. Set values on the number boxes to the left., f 39;
#X connect 0 0 16 0;
#X connect 1 0 16 1;
#X connect 2 0 3 0;
#X connect 4 0 7 0;
#X connect 5 0 4 0;
#X connect 5 0 2 0;
#X connect 6 0 5 0;
#X connect 15 0 17 0;
#X connect 16 0 14 0;
#X connect 17 0 2 0;
#X connect 17 1 4 0;
#X restore 340 480 pd multi-channel;
#X text 89 481 see multi channel example here -->;
#X text 37 88 A [send~] object copies its input to a local buffer which all [receive~] objects of the same name read from. They may be in different windows or even different patches. Any number of [receive~] may be associated with one [send~] \, but it is an error to have two [send~] objects of the same name. [receive~] takes "set" messages to switch between different [send~] objects. Multi channel connections is supported., f 72;
#X text 72 418 [send~]/[receive~] must have matching block sizes and numbers of channels. Block size is a property of the patch and number of channels is specified via a second argument (default 1)., f 62;
#X text 162 13 - one-to-many nonlocal signal(s) connection;
#X text 117 514 Example for feedback loops -->;
#N canvas 639 104 520 539 feedback-loop 0;
#X text 42 20 You can use [send~]/[receive~] for feedback loops. Feedback loops are also useful in delay lines as shown in some of the examples in the 'G' series of the audio examples. Feedback loops with delay lines are useful when you need to change the delay size \, but sometimes you want a fixed delay time.;
#X text 42 105 The delay time for [send~]/[receive~] is fixed at one block and you can use it as the desired fixed delay time. You can change the block size for a patch window with the [block~] object \, the default block size is 64 but common examlpes are a single sample feedback loop (block size of 1 for things like filter design and more) or FFT processing with block sizes that are much larger (like 1024 or 2048).;
#X text 54 428 Note that feedback loops usually requites a single connection \, in this case you can also use [throw~]/[catch~]. Hence \, the decision to focus on [send~]/[receive~] instead is a bit arbitrary., f 62;
#X obj 244 303 *~ 0.1;
#X obj 244 273 r~ \$0-fb;
#X obj 209 349 s~ \$0-fb;
#X obj 180 274 noise~;
#X obj 180 305 +~;
#X obj 69 323 block~ 1;
#X obj 181 391 print~;
#X text 42 215 For reference \, below we have an implementation of [rpole~] real one pole filter (like ), f 60;
#X text 298 305 filter coefficient;
#X text 350 348 see also:;
#X obj 364 377 rpole~;
#X connect 3 0 7 1;
#X connect 4 0 3 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X connect 7 0 9 0;
#X restore 341 514 pd feedback-loop;
#X obj 230 609 delread~;
#X obj 295 609 block~;
#X obj 4 594 cnv 1 580 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 421 41 click =>;
#X obj 129 609 send;
#X text 152 544 How to prevent delays -->;
#X connect 1 0 20 0;
#X connect 2 0 0 0;
#X connect 3 0 2 0;
#X connect 3 0 17 0;
#X connect 4 0 21 0;
#X connect 11 0 3 0;
#X connect 12 0 13 0;
#X connect 15 0 1 0;
#X connect 17 0 16 0;
#X connect 22 0 28 0;
#X connect 23 0 28 0;
#X connect 24 0 23 0;
#X connect 25 0 24 0;
#X connect 26 0 4 0;
#X connect 28 0 2 0;
#X connect 33 0 17 0;
