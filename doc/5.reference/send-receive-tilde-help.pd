#N canvas 407 23 591 646 12;
#X floatatom 334 382 5 0 0 0 - - - 0;
#X obj 46 235 sig~ 50;
#X obj 334 352 snapshot~;
#X obj 334 303 metro 200;
#X obj 46 342 sig~ 25;
#X obj 166 609 tabsend~;
#X obj 98 42 s~;
#X obj 129 42 r~;
#X text 11 609 see also:;
#X obj 78 609 throw~;
#X text 162 41 - abbreviation;
#X obj 334 271 loadbang;
#X floatatom 46 209 5 0 0 0 - - - 0;
#X floatatom 426 382 5 0 0 0 - - - 0;
#X obj 426 352 snapshot~;
#X obj 18 14 send~ x;
#X obj 78 14 receive~ x;
#X obj 46 262 send~ \$0-signal;
#X obj 46 370 send~ signal;
#X msg 198 283 set signal;
#X msg 186 256 set \$1-signal;
#X obj 186 232 f \$0;
#X obj 186 207 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X floatatom 46 315 5 0 0 0 - - - 0;
#N canvas 597 199 505 182 execution-order 0;
#X obj 114 123 ../3.audio.examples/G05.execution.order;
#X text 46 30 You have to get the [send~] sorted before the [receive~] or else you'll potentially get a one block delay. Although this is inevitable for feedback loops \, it should be mostly desired in other cases. You can use the strategy given in the example below to control this., f 61;
#X restore 341 546 pd execution-order;
#X obj 186 311 receive~ \$0-signal;
#N canvas 697 108 568 452 reference 0;
#X obj 8 53 cnv 5 550 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X obj 8 124 cnv 2 550 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000 0;
#X obj 6 165 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 8 212 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 8 351 cnv 2 550 2 empty empty OUTLET: 8 12 0 13 #202020 #000000 0;
#X obj 8 396 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 7 433 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X text 146 134 NONE;
#X obj 28 15 send~ y;
#X obj 24 275 receive~ y;
#X obj 8 311 cnv 5 550 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X text 124 169 1) symbol - send symbol name (default: empty symbol).;
#X text 106 406 1) symbol - receive name symbol (default: empty symbol).;
#X text 131 189 2) float - number of channels (default: 1)., f 52;
#X text 89 15 - send signal(s) to one or more [receive~] objects.;
#X text 107 274 - receive signal(s) from a [send~] object.;
#X text 119 67 signal - signal(s) to send to matching [receive~] object(s).;
#X text 48 91 channels <float> - set number of channels to send.;
#X text 98 362 signal(s) - outputs signal(s) from a matching [send~] object., f 61;
#X text 109 324 set <symbol> - set receive name.;
#X restore 485 42 pd reference;
#X obj 4 74 cnv 1 580 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 225 211 \$0 needs to be expanded from objects., f 23;
#X text 376 609 updated for Pd version 0.54;
#X obj 426 319 r~ signal;
#N canvas 695 29 499 591 multi-channel 0;
#X floatatom 71 99 5 0 0 0 - - - 0;
#X floatatom 145 99 5 0 0 0 - - - 0;
#X obj 111 409 snapshot~;
#X floatatom 111 435 8 0 0 0 - - - 0;
#X obj 192 409 snapshot~;
#X obj 214 371 metro 250;
#X obj 214 342 loadbang;
#X floatatom 192 435 8 0 0 0 - - - 0;
#X text 352 366 see also:;
#X obj 399 394 clone;
#X obj 71 219 send~ cat 2;
#X obj 71 129 snake~ in 2;
#X obj 111 343 snake~ out 2;
#X obj 342 394 snake~;
#X obj 111 293 receive~ cat;
#X text 210 289 <-- receive outputs the same number of channels, f 23;
#X msg 94 160 channels 1;
#X msg 109 185 channels 2;
#X text 43 18 This example shows how to set number of channels as the 2nd argument to [send~] \, so it can take a multichannel signal. You can also change the number of channels with the 'channels' message., f 52;
#X text 208 167 set number of channels., f 12;
#X text 157 219 <-- 2nd argument sets number of channels, f 21;
#X text 193 98 <-- change values;
#X text 183 166 <--;
#X msg 344 183 \; pd dsp \$1;
#X obj 344 148 set-dsp-tgl;
#X text 375 152 DSP on/off;
#X text 43 479 Note: you can use "set" messages to switch a [receive~] between multichannel [send~] objects with different numbers of channels \, but this can only be done while DSP is off. When DSP is on the [send~] channel counts stays fixed!, f 55;
#X connect 0 0 11 0;
#X connect 1 0 11 1;
#X connect 2 0 3 0;
#X connect 4 0 7 0;
#X connect 5 0 4 0;
#X connect 5 0 2 0;
#X connect 6 0 5 0;
#X connect 11 0 10 0;
#X connect 12 0 2 0;
#X connect 12 1 4 0;
#X connect 14 0 12 0;
#X connect 16 0 10 0;
#X connect 17 0 10 0;
#X connect 24 0 23 0;
#X restore 340 480 pd multi-channel;
#X text 89 481 see multi channel example here -->;
#X text 37 88 A [send~] object copies its input to a local buffer which all [receive~] objects of the same name read from. They may be in different windows or even different patches. Any number of [receive~] may be associated with one [send~] \, but it is an error to have two [send~] objects of the same name. [receive~] takes "set" messages to switch between different [send~] objects. Multi channel connections is supported., f 72;
#X text 162 13 - one-to-many nonlocal signal(s) connection;
#X text 117 514 Example for feedback loops -->;
#N canvas 639 104 520 539 feedback-loop 0;
#X text 42 20 You can use [send~]/[receive~] for feedback loops. Feedback loops are also useful in delay lines as shown in some of the examples in the 'G' series of the audio examples. Feedback loops with delay lines are useful when you need to change the delay size \, but sometimes you want a fixed delay time.;
#X text 54 428 Note that feedback loops usually requites a single connection \, in this case you can also use [throw~]/[catch~]. Hence \, the decision to focus on [send~]/[receive~] instead is a bit arbitrary., f 62;
#X obj 244 303 *~ 0.1;
#X obj 244 273 r~ \$0-fb;
#X obj 209 349 s~ \$0-fb;
#X obj 180 274 noise~;
#X obj 180 305 +~;
#X obj 69 323 block~ 1;
#X obj 181 391 print~;
#X text 42 215 For reference \, below we have an implementation of [rpole~] real one pole filter (like ), f 60;
#X text 298 305 filter coefficient;
#X text 350 348 see also:;
#X obj 364 377 rpole~;
#X text 42 105 The delay time for [send~]/[receive~] is fixed at one block and you can use it as the desired fixed delay time. You can change the block size for a patch window with the [block~] object \, the default block size is 64 but common examples are a single sample feedback loop (block size of 1 for things like filter design and more) or FFT processing with block sizes that are much larger (like 1024 or 2048).;
#X connect 2 0 6 1;
#X connect 3 0 2 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X connect 6 0 8 0;
#X restore 341 514 pd feedback-loop;
#X obj 230 609 delread~;
#X obj 295 609 block~;
#X obj 4 594 cnv 1 580 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 421 41 click =>;
#X obj 129 609 send;
#X text 152 544 How to prevent delays -->;
#X msg 443 250 \; pd dsp \$1;
#X obj 443 215 set-dsp-tgl;
#X text 474 219 DSP on/off;
#X text 72 418 [send~]/[receive~] must have matching block sizes., f 62;
#X connect 1 0 17 0;
#X connect 2 0 0 0;
#X connect 3 0 2 0;
#X connect 3 0 14 0;
#X connect 4 0 18 0;
#X connect 11 0 3 0;
#X connect 12 0 1 0;
#X connect 14 0 13 0;
#X connect 19 0 25 0;
#X connect 20 0 25 0;
#X connect 21 0 20 0;
#X connect 22 0 21 0;
#X connect 23 0 4 0;
#X connect 25 0 2 0;
#X connect 30 0 14 0;
#X connect 44 0 43 0;
