#N canvas 366 23 745 703 12;
#X declare -stdpath ./;
#N canvas 302 55 911 485 Arrays 0;
#X floatatom 123 370 4 0 9 0 - - - 0;
#X floatatom 123 427 10 0 0 0 - - - 0;
#X obj 123 399 expr $s2[$f1];
#X floatatom 112 94 5 0 9 0 - - - 0;
#X floatatom 112 170 9 0 0 0 - - - 0;
#X text 55 56 For instance:;
#X obj 211 342 loadbang;
#X floatatom 502 232 0 0 100 0 - - - 0;
#X text 47 16 [expr] \, [expr~] and [fexpr~] can read values from array (without interpolation). The syntax is arrayname[index].;
#X text 28 281 A symbol inlet - defined as '$s#' (# being the inlet number) - is used to receive the array names., f 55;
#X text 573 218 [expr] can set values to an array index with "=" (a.k.a. "store function") as in:, f 41;
#X text 27 210 Note that variables '$f#' are also possible as the array index \, but it won't make sense since there's no interpolation and float inputs are just truncated to integers., f 55;
#X text 516 325 Even though you can also use arrays in [expr~] and [fexpr~]. They cannot write values to arrays and the index values cannot be audio variables (just either '$i3' or '$f#')., f 39;
#X msg 211 368 symbol array100;
#X obj 112 131 expr array100[$i1];
#X obj 502 263 expr array100[1] = $f1;
#X obj 660 403 expr~ $v1 + array100[1];
#X obj 660 430 fexpr~ $x1 + array100[1];
#X obj 502 46 vsl 19 162 0 10 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X text 154 93 <-- index to read from the array, f 33;
#X obj 577 30 cnv 19 218 128 empty empty empty 20 12 0 12 #ffffff #404040 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array array100 10 float 1;
#A 0 1 6.77019 2 8 5 6 1 4 2 8;
#X coords 0 10 9 0 220 130 1 0 0;
#X restore 576 29 graph;
#X connect 0 0 2 0;
#X connect 2 0 1 0;
#X connect 3 0 14 0;
#X connect 6 0 13 0;
#X connect 7 0 15 0;
#X connect 13 0 2 1;
#X connect 14 0 4 0;
#X connect 18 0 7 0;
#X restore 505 497 pd Arrays;
#X text 88 499 Basic examples:;
#X text 429 520 Further details:, f 8;
#N canvas 350 134 950 501 Dealing_with_"\$0" 0;
#X obj 624 154 expr $s2[$f1];
#X obj 712 123 symbol \$0-x;
#X floatatom 624 128 5 0 99 0 - - - 0;
#X floatatom 624 182 5 0 0 0 - - - 0;
#X obj 712 100 loadbang;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-x 100 float 1;
#A 0 -0.720016 -0.706683 -0.693349 -0.680016 -0.666682 -0.653348 -0.640015 -0.625014 -0.610014 -0.595014 -0.580013 -0.565013 -0.550013 -0.535012 -0.520012 -0.505012 -0.490011 -0.475011 -0.460011 -0.44501 -0.43001 -0.415009 -0.400009 -0.385009 -0.370008 -0.355008 -0.340008 -0.325007 -0.310007 -0.295007 -0.280006 -0.264006 -0.248006 -0.232005 -0.216005 -0.200005 -0.184004 -0.168004 -0.152003 -0.136003 -0.120003 -0.106669 -0.0933355 -0.0800018 -0.0666682 -0.0533346 -0.0400009 -0.0266673 -0.0133336 -3.10441e-10 0.0133336 0.0266673 0.0400009 0.0533346 0.0666682 0.0800018 0.0933355 0.106669 0.120003 0.133336 0.14667 0.160004 0.173337 0.186671 0.200005 0.213338 0.226672 0.240005 0.253339 0.266673 0.280006 0.29715 0.314293 0.331436 0.348579 0.365723 0.382866 0.400009 0.413343 0.426676 0.44001 0.453344 0.466677 0.480011 0.500011 0.520012 0.540012 0.560013 0.570013 0.580013 0.590014 0.600014 0.620014 0.640015 0.660015 0.680016 0.680016 0.720016 0.720016 0.720016;
#X coords 0 1 99 -1 200 150 1 0 0;
#X restore 249 188 graph;
#X obj 58 397 expr \$0-x[$f1];
#X floatatom 58 363 5 0 99 0 - - - 0;
#X floatatom 58 433 5 0 0 0 - - - 0;
#X obj 767 406 value x\$0;
#X obj 809 374 value y_\$0;
#X obj 590 354 expr x\$0 \; y_\$0;
#X msg 767 376 1.3;
#X msg 809 344 4.7;
#X obj 767 304 loadbang;
#X floatatom 650 403 5 0 0 0 - - - 0;
#X floatatom 590 403 5 0 0 0 - - - 0;
#X text 514 245 A simpler practice that will always work for both table names and variables is to just have '\$0' after a symbol character \, such as:;
#X text 33 200 On the other hand \, the '-' character is used for the subtraction operator. Thus \, '\$0-x' is interpreted as "ID number" minus 'x' in the [expr] object below and not as the array name to the right., f 27;
#X text 198 378 This does load the object even though "\$0-x" doesn't correspond to the array name. But see how the Pd window gives an error that it can't find the 'x' table when trying to produce an output., f 40;
#X text 500 23 A solution for such array name issues is to send the table name as a symbol input. But this doesn't deal with variable names as they can't be loaded as symbols!;
#X text 57 458 error;
#X text 670 184 (works);
#X text 21 6 '\$0' - the patch ID number used to force locality in Pd - may be used in the definition local array names in [expr] \, [expr~] or [fexpr~]. You can also use it to set local variable names in value objects that are retrieved in [expr] \, [expr~] and [fexpr~]. This is specially useful in abstractions., f 62;
#X text 21 89 But it is important to note the restrictions of adopting the C-style expression syntax \, where symbols cannot start with a number \, so '\$0x' or '\$0_x' are illegal as Pd turns '\$0' into a number and thus the object won't load giving a syntax error!, f 62;
#X obj 590 323 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 538 127 try now -->;
#X text 100 362 <-- try;
#X connect 0 0 3 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 4 0 1 0;
#X connect 6 0 8 0;
#X connect 7 0 6 0;
#X connect 11 0 16 0;
#X connect 11 1 15 0;
#X connect 12 0 9 0;
#X connect 13 0 10 0;
#X connect 14 0 12 0;
#X connect 14 0 13 0;
#X connect 25 0 11 0;
#X restore 505 524 pd Dealing_with_"\$0";
#X text 28 607 see also:;
#X obj 285 671 block~;
#X obj 339 671 value;
#N canvas 700 94 468 543 All_functions 0;
#N canvas 497 97 374 326 Arithmetic-operators 0;
#X obj 57 90 expr $f1 + 4;
#X floatatom 57 63 5 0 0 0 - - - 0;
#X floatatom 57 118 5 0 0 0 - - - 0;
#X floatatom 208 63 5 0 0 0 - - - 0;
#X floatatom 208 118 5 0 0 0 - - - 0;
#X obj 208 90 expr $f1 * 4;
#X floatatom 57 197 5 0 0 0 - - - 0;
#X floatatom 57 252 5 0 0 0 - - - 0;
#X floatatom 208 197 5 0 0 0 - - - 0;
#X floatatom 208 252 5 0 0 0 - - - 0;
#X obj 57 224 expr $f1 - 1;
#X obj 208 224 expr $f1 / 10;
#X text 57 34 Add;
#X text 206 34 Multiply;
#X text 206 174 Divide;
#X text 56 174 Subtract;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 3 0 5 0;
#X connect 5 0 4 0;
#X connect 6 0 10 0;
#X connect 8 0 11 0;
#X connect 10 0 7 0;
#X connect 11 0 9 0;
#X restore 125 136 pd Arithmetic-operators;
#N canvas 379 126 621 391 Bitwise-operators 0;
#X floatatom 47 328 5 0 0 0 - - - 0;
#X obj 47 294 expr ~ $f1;
#X floatatom 44 103 5 0 0 0 - - - 0;
#X obj 44 71 expr $f1 & 3;
#X floatatom 44 37 5 0 0 0 - - - 0;
#X text 104 36 Bitwise And;
#X floatatom 347 103 5 0 0 0 - - - 0;
#X floatatom 347 37 5 0 0 0 - - - 0;
#X obj 347 71 expr $f1 << 1;
#X floatatom 349 214 5 0 0 0 - - - 0;
#X floatatom 349 148 5 0 0 0 - - - 0;
#X text 404 147 Bitshift Right;
#X text 413 36 Bitshift Left;
#X obj 349 181 expr $f1 >> 2;
#X floatatom 353 328 5 0 0 0 - - - 0;
#X floatatom 353 258 5 0 0 0 - - - 0;
#X obj 353 294 expr $f1 ^ 1;
#X text 409 257 Bitwise Exclusive Or;
#X floatatom 47 214 5 0 0 0 - - - 0;
#X floatatom 47 148 5 0 0 0 - - - 0;
#X text 109 147 Bitwise Or;
#X obj 47 181 expr $f1 | 3;
#X floatatom 47 258 5 0 0 0 - - - 0;
#X text 97 257 Bitwise Not;
#X text 141 293 (one's complement);
#X connect 1 0 0 0;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 7 0 8 0;
#X connect 8 0 6 0;
#X connect 10 0 13 0;
#X connect 13 0 9 0;
#X connect 15 0 16 0;
#X connect 16 0 14 0;
#X connect 19 0 21 0;
#X connect 21 0 18 0;
#X connect 22 0 1 0;
#X restore 125 229 pd Bitwise-operators;
#N canvas 458 88 472 464 If-function 0;
#X floatatom 82 53 5 0 0 0 - - - 0;
#X floatatom 82 112 5 0 0 0 - - - 0;
#X floatatom 87 218 5 0 0 0 - - - 0;
#X floatatom 87 277 5 0 0 0 - - - 0;
#X text 142 213 if(condition \, true \, false);
#X obj 87 246 expr if($f1 > 0 \, $f1 * 10 \, $f1 - 1);
#X floatatom 59 346 5 0 0 0 - - - 0;
#X floatatom 59 405 5 0 0 0 - - - 0;
#X obj 59 374 expr if($f1 > 10 \, 10 \, if($f1 < -10 \, -10 \, $f1));
#X text 118 404 <= clips at -10 and 10;
#X obj 82 81 expr if($f1 >= 0 \, 1 \, -1);
#X text 53 21 Syntax: if(condition \, true \, false);
#X text 143 325 You can also nest an if function as a true/false expression:, f 32;
#X text 39 163 It accepts expressions as true/false as well:;
#X connect 0 0 10 0;
#X connect 2 0 5 0;
#X connect 5 0 3 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 10 0 1 0;
#X restore 125 261 pd If-function;
#N canvas 444 91 443 422 Random-function 0;
#X floatatom 107 187 5 0 0 0 - - - 0;
#X obj 107 156 expr random(10 \, 20);
#X text 130 125 random values from 10 to 19;
#X floatatom 108 287 5 0 0 0 - - - 0;
#X obj 108 256 expr random(-100 \, 101);
#X text 133 228 random values from -100 to 100;
#X text 36 32 The random function generates random numbers within a given range \, specified by the two arguments. The range is from the first argument to the second argument minus one., f 51;
#X obj 107 125 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 108 228 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 54 325 Unlike other pseudo number generators in Pd \, you cannot set a seed value., f 49;
#X text 57 375 see also:;
#X obj 131 375 random;
#X obj 189 375 noise~;
#X obj 247 375 array random;
#X connect 1 0 0 0;
#X connect 4 0 3 0;
#X connect 7 0 1 0;
#X connect 8 0 4 0;
#X restore 125 292 pd Random-function;
#N canvas 292 68 604 529 Table-functions 0;
#X floatatom 63 163 0 0 0 0 - - - 0;
#X floatatom 145 164 0 0 0 0 - - - 0;
#X floatatom 228 164 0 0 0 0 - - - 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array table 100 float 1;
#A 0 0 1 2 3 4 5 6 7 8 9 18.5714 21.4285 28.5713 31.4284 34.9998 38.5712 40.714 42.8569 46.4283 49.2854 50.3568 51.4282 53.5711 54.2853 54.9996 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.5353 55.3568 55.1782 54.9996 54.2853 53.5711 52.8568 52.1425 51.4282 49.9997 48.5711 47.1426 45.714 44.0473 42.3807 40.714 39.0474 37.3807 35.7141 32.857 31.4284 29.9999 28.5713 26.4285 26.4285 26.7856 27.1427 27.857 28.5713 29.107 29.6427 30.1784 30.7141 31.607 32.4998 33.3927 34.2855 34.9998 35.7141 36.6665 37.6188 38.5712 40.714 41.4283 42.1426 44.2854 45.714 46.7854 47.8568 49.9997 51.4282 52.8568 55.7139 57.8567 59.9996 62.8567 64.9995 66.4281 69.2852 72.1423 93 94 95 96 97 98 99;
#X coords 0 100 99 0 200 140 1 0 0;
#X restore 336 118 graph;
#X obj 364 422 expr size("$s1") \;;
#X obj 63 102 expr Sum("table" \, 3 \, 9) \; sum("table") \; size("table");
#X msg 364 392 symbol table;
#X floatatom 364 455 5 0 0 0 - - - 0;
#X text 64 187 Sums a range of indexes, f 8;
#X text 146 189 Sums all indexes, f 8;
#X text 225 189 Gives array size, f 5;
#X floatatom 47 344 0 0 0 0 - - - 0;
#X floatatom 240 344 0 0 0 0 - - - 0;
#X floatatom 47 469 0 0 0 0 - - - 0;
#X floatatom 212 467 0 0 0 0 - - - 0;
#X obj 47 299 expr avg("table") \; sum("table") / size("table");
#X obj 47 424 expr Avg("table" \, 3 \, 9) \; Sum("table" \, 3 \, 9) / 7;
#X text 73 267 avg - Averages all indexes;
#X text 72 396 Avg - averages a range of indexes;
#X text 127 26 There are 5 functions that operate on arrays: Avg \, avg \, Sum \, sum and size., f 45;
#X text 354 286 You can use a symbol type to specify the array name. Note that the syntax requires that the array name is inside quotes., f 23;
#X obj 63 73 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 47 269 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 47 396 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X connect 4 0 7 0;
#X connect 5 0 0 0;
#X connect 5 1 1 0;
#X connect 5 2 2 0;
#X connect 6 0 4 0;
#X connect 15 0 11 0;
#X connect 15 1 12 0;
#X connect 16 0 13 0;
#X connect 16 1 14 0;
#X connect 21 0 5 0;
#X connect 22 0 15 0;
#X connect 23 0 16 0;
#X restore 125 361 pd Table-functions;
#N canvas 286 64 570 578 Power-functions 0;
#X floatatom 62 60 5 0 0 0 - - - 0;
#X floatatom 62 119 5 0 0 0 - - - 0;
#X floatatom 62 151 5 0 0 0 - - - 0;
#X floatatom 62 208 5 0 0 0 - - - 0;
#X floatatom 59 337 5 0 0 0 - - - 0;
#X floatatom 59 409 0 0 0 0 - - - 0;
#X floatatom 306 103 5 0 0 0 - - - 0;
#X floatatom 394 101 5 0 0 0 - - - 0;
#X floatatom 306 31 5 0 0 0 - - - 0;
#X floatatom 308 414 5 0 0 0 - - - 0;
#X floatatom 308 484 0 0 0 0 - - - 0;
#X floatatom 62 513 5 0 0 0 - - - 0;
#X obj 62 88 expr pow($f1 \, 2);
#X floatatom 306 276 5 0 0 0 - - - 0;
#X floatatom 306 224 5 0 0 0 - - - 0;
#X obj 306 56 expr ln($f1) \; log($f1);
#X obj 62 484 expr fact($f1);
#X msg 62 451 3;
#X floatatom 403 482 0 0 0 0 - - - 0;
#X floatatom 154 408 0 0 0 0 - - - 0;
#X floatatom 307 187 5 0 0 0 - - - 0;
#X floatatom 307 135 5 0 0 0 - - - 0;
#X obj 307 160 expr log1p($f1);
#X obj 306 249 expr log10($f1);
#X floatatom 309 375 5 0 0 0 - - - 0;
#X floatatom 309 323 5 0 0 0 - - - 0;
#X obj 309 348 expr ldexp($f1 \, 3);
#X obj 59 365 expr exp($f1) \; expm1($f1);
#X floatatom 61 239 5 0 0 0 - - - 0;
#X floatatom 61 296 5 0 0 0 - - - 0;
#X obj 62 179 expr sqrt($f1);
#X obj 61 267 expr cbrt($f1);
#X text 171 382 exp - 1;
#X text 235 507 error function;
#X text 402 505 complementary error function, f 14;
#X obj 308 442 expr erf($f1) \; erfc($f1);
#X text 64 33 Raise to the power of;
#X text 129 148 Square root;
#X text 138 239 Cube root;
#X text 121 324 Exp: 'e' raised to the power of, f 15;
#X text 98 451 Factorial;
#X text 353 29 Natural log;
#X text 365 133 Natural log of input + 1;
#X text 353 221 Log base 10;
#X text 364 307 Multiply by integral power of 2, f 20;
#X text 368 409 Error functions;
#X text 112 54 second argument;
#X connect 0 0 12 0;
#X connect 2 0 30 0;
#X connect 4 0 27 0;
#X connect 8 0 15 0;
#X connect 9 0 35 0;
#X connect 12 0 1 0;
#X connect 14 0 23 0;
#X connect 15 0 6 0;
#X connect 15 1 7 0;
#X connect 16 0 11 0;
#X connect 17 0 16 0;
#X connect 21 0 22 0;
#X connect 22 0 20 0;
#X connect 23 0 13 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 27 0 5 0;
#X connect 27 1 19 0;
#X connect 28 0 31 0;
#X connect 30 0 3 0;
#X connect 31 0 29 0;
#X connect 35 0 10 0;
#X connect 35 1 18 0;
#X restore 125 394 pd Power-functions;
#N canvas 241 137 849 422 Trigonometric-functions 0;
#X floatatom 34 54 5 0 0 0 - - - 0;
#X floatatom 34 113 5 0 0 0 - - - 0;
#X floatatom 34 145 5 0 0 0 - - - 0;
#X floatatom 34 202 5 0 0 0 - - - 0;
#X floatatom 33 233 5 0 0 0 - - - 0;
#X floatatom 33 290 5 0 0 0 - - - 0;
#X obj 34 82 expr sin($f1);
#X obj 34 173 expr cos($f1);
#X obj 33 261 expr tan($f1);
#X floatatom 194 54 5 0 0 0 - - - 0;
#X floatatom 194 113 5 0 0 0 - - - 0;
#X floatatom 194 145 5 0 0 0 - - - 0;
#X floatatom 194 202 5 0 0 0 - - - 0;
#X obj 194 82 expr asin($f1);
#X obj 194 173 expr acos($f1);
#X text 83 52 sine;
#X text 85 145 cosine;
#X text 84 233 tangent;
#X floatatom 195 229 5 0 0 0 - - - 0;
#X floatatom 195 286 5 0 0 0 - - - 0;
#X text 261 52 arc sine;
#X text 256 145 arc cosine;
#X text 256 229 arc tangent;
#X floatatom 387 53 5 0 0 0 - - - 0;
#X floatatom 387 112 5 0 0 0 - - - 0;
#X floatatom 387 144 5 0 0 0 - - - 0;
#X floatatom 387 201 5 0 0 0 - - - 0;
#X floatatom 388 228 5 0 0 0 - - - 0;
#X floatatom 388 285 5 0 0 0 - - - 0;
#X floatatom 264 329 5 0 0 0 - - - 0;
#X floatatom 264 386 5 0 0 0 - - - 0;
#X obj 264 357 expr atan2($f1 \, $f2);
#X floatatom 401 329 5 0 0 0 - - - 0;
#X text 426 357 arc tangent of 2 variables;
#X obj 195 257 expr atan($f1);
#X floatatom 617 53 5 0 0 0 - - - 0;
#X floatatom 617 112 5 0 0 0 - - - 0;
#X floatatom 617 144 5 0 0 0 - - - 0;
#X floatatom 617 201 5 0 0 0 - - - 0;
#X floatatom 618 228 5 0 0 0 - - - 0;
#X floatatom 618 285 5 0 0 0 - - - 0;
#X text 741 66 inverse hyperbolic sine, f 10;
#X obj 617 81 expr asinh($f1);
#X obj 617 172 expr acosh($f1);
#X obj 618 256 expr atanh($f1);
#X text 742 157 inverse hyperbolic cosine, f 10;
#X text 743 245 inverse hyperbolic tangent, f 10;
#X obj 387 81 expr sinh($f1);
#X obj 387 172 expr cosh($f1);
#X obj 388 256 expr tanh($f1);
#X text 503 255 hyperbolic tangent, f 10;
#X text 502 167 hyperbolic cosine, f 10;
#X text 501 76 hyperbolic sine, f 10;
#X text 112 12 All trigonometric functions expect the input in radians (except the arc or inverse ones)., f 89;
#X connect 0 0 6 0;
#X connect 2 0 7 0;
#X connect 4 0 8 0;
#X connect 6 0 1 0;
#X connect 7 0 3 0;
#X connect 8 0 5 0;
#X connect 9 0 13 0;
#X connect 11 0 14 0;
#X connect 13 0 10 0;
#X connect 14 0 12 0;
#X connect 18 0 34 0;
#X connect 23 0 47 0;
#X connect 25 0 48 0;
#X connect 27 0 49 0;
#X connect 29 0 31 0;
#X connect 31 0 30 0;
#X connect 32 0 31 1;
#X connect 34 0 19 0;
#X connect 35 0 42 0;
#X connect 37 0 43 0;
#X connect 39 0 44 0;
#X connect 42 0 36 0;
#X connect 43 0 38 0;
#X connect 44 0 40 0;
#X connect 47 0 24 0;
#X connect 48 0 26 0;
#X connect 49 0 28 0;
#X restore 125 427 pd Trigonometric-functions;
#N canvas 307 85 592 281 Store-function 0;
#X text 40 26 The store function is defined with "=" \, and it can store the result of any operation into a variable or table index.;
#X floatatom 62 211 5 0 0 0 - - - 0;
#X floatatom 276 211 5 0 0 0 - - - 0;
#X obj 62 158 expr array2[inc - 1] = 1 / inc \; inc = inc + 1;
#N canvas 0 22 450 278 (subpatch) 0;
#X array array2 16 float 2;
#X coords 0 1.1 16 -0.1 200 140 1 0 0;
#X restore 351 101 graph;
#X obj 129 119 v inc;
#X msg 129 94 0;
#X obj 62 129 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X connect 3 0 1 0;
#X connect 3 1 2 0;
#X connect 6 0 5 0;
#X connect 7 0 3 0;
#X restore 125 326 pd Store-function;
#X text 46 19 Here are all the operators and functions available for [expr] \, [expr~] and [fexpr~] \, even though the given examples are only presented with [expr]., f 52;
#X text 46 76 These are organized in different groups. Click on the subpatches below to check each group:, f 52;
#N canvas 202 125 850 540 Other-functions 0;
#X floatatom 54 26 5 0 0 0 - - - 0;
#X floatatom 54 99 5 0 0 0 - - - 0;
#X text 163 54 convert to int;
#X floatatom 49 272 5 0 0 0 - - - 0;
#X floatatom 49 362 5 0 0 0 - - - 0;
#X text 102 142 convert to float;
#X floatatom 50 217 5 0 0 0 - - - 0;
#X floatatom 194 215 5 0 0 0 - - - 0;
#X floatatom 50 143 5 0 0 0 - - - 0;
#X floatatom 342 32 5 0 0 0 - - - 0;
#X floatatom 342 108 5 0 0 0 - - - 0;
#X floatatom 458 105 5 0 0 0 - - - 0;
#X obj 342 60 expr max($f1 \, 0) \; min($f1 \, 0);
#X text 394 30 maximum / minimum;
#X obj 321 172 expr copysign($f1 \, $f2);
#X floatatom 479 149 5 0 0 0 - - - 0;
#X floatatom 321 147 5 0 0 0 - - - 0;
#X floatatom 321 201 5 0 0 0 - - - 0;
#X text 367 200 copy sign of a number;
#X obj 50 170 expr float($i1) / 10 \; float(5) / 10 \;;
#X floatatom 593 164 5 0 0 0 - - - 0;
#X floatatom 702 163 5 0 0 0 - - - 0;
#X obj 593 119 expr isinf($f1) \; finite($f1);
#X text 721 117 "is infinite" and "is finite", f 15;
#X floatatom 593 87 5 0 0 0 - - - 0;
#X msg 633 29 2;
#X obj 593 54 pow 1e+10;
#X msg 593 27 1;
#X floatatom 601 347 5 0 0 0 - - - 0;
#X floatatom 601 285 5 0 0 0 - - - 0;
#X obj 601 315 expr isnan($f1);
#X text 722 295 "is Nan" (not a number), f 8;
#X floatatom 341 242 5 0 0 0 - - - 0;
#X floatatom 341 311 5 0 0 0 - - - 0;
#X obj 54 54 expr int($f1) \; trunc($f1);
#X floatatom 149 99 5 0 0 0 - - - 0;
#X text 163 69 truncate a float;
#X floatatom 100 362 5 0 0 0 - - - 0;
#X floatatom 151 362 5 0 0 0 - - - 0;
#X obj 49 303 expr rint($f1) \; round($f1) \; nearbyint($f1);
#X floatatom 322 415 5 0 0 0 - - - 0;
#X floatatom 322 495 5 0 0 0 - - - 0;
#X floatatom 387 495 5 0 0 0 - - - 0;
#X floatatom 52 421 5 0 0 0 - - - 0;
#X floatatom 52 494 5 0 0 0 - - - 0;
#X floatatom 154 494 5 0 0 0 - - - 0;
#X text 101 420 ceil / floor;
#X obj 52 449 expr ceil($f1) \; floor($f1);
#X obj 341 268 expr imodf($f1) \; modf($f1);
#X text 325 332 get signed integer, f 10;
#X text 435 334 get signed fractional, f 11;
#X floatatom 450 311 5 0 0 0 - - - 0;
#X floatatom 632 400 5 0 0 0 - - - 0;
#X obj 632 437 expr abs($f1);
#X floatatom 632 474 5 0 0 0 - - - 0;
#X text 680 399 absolute value;
#X obj 601 225 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000;
#X msg 322 384 7;
#X obj 601 251 expr log(-1);
#X text 100 264 round floats to integers, f 12;
#X floatatom 452 495 5 0 0 0 - - - 0;
#X msg 289 384 -7;
#X text 458 440 (integer);
#X text 458 454 (float);
#X obj 322 440 expr $f1 % 4 \; fmod($f1 \, 4.1) \; remainder($f1 \, 4.1);
#X text 371 412 remainder functions;
#X text 105 27 convert to integers;
#X connect 0 0 34 0;
#X connect 3 0 39 0;
#X connect 8 0 19 0;
#X connect 9 0 12 0;
#X connect 12 0 10 0;
#X connect 12 1 11 0;
#X connect 14 0 17 0;
#X connect 15 0 14 1;
#X connect 16 0 14 0;
#X connect 19 0 6 0;
#X connect 19 1 7 0;
#X connect 22 0 20 0;
#X connect 22 1 21 0;
#X connect 24 0 22 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 27 0 26 0;
#X connect 29 0 30 0;
#X connect 30 0 28 0;
#X connect 32 0 48 0;
#X connect 34 0 1 0;
#X connect 34 1 35 0;
#X connect 39 0 4 0;
#X connect 39 1 37 0;
#X connect 39 2 38 0;
#X connect 40 0 64 0;
#X connect 43 0 47 0;
#X connect 47 0 44 0;
#X connect 47 1 45 0;
#X connect 48 0 33 0;
#X connect 48 1 51 0;
#X connect 52 0 53 0;
#X connect 53 0 54 0;
#X connect 56 0 58 0;
#X connect 57 0 40 0;
#X connect 58 0 29 0;
#X connect 61 0 40 0;
#X connect 64 0 41 0;
#X connect 64 1 42 0;
#X connect 64 2 60 0;
#X restore 124 492 pd Other-functions;
#N canvas 369 170 564 371 Acoustics 0;
#X floatatom 70 109 0 0 0 0 - - - 0;
#X floatatom 70 164 0 0 0 0 - - - 0;
#X floatatom 70 213 0 0 0 0 - - - 0;
#X obj 70 137 expr mtof($f1);
#X obj 70 189 expr ftom($f1);
#X floatatom 216 109 0 0 0 0 - - - 0;
#X floatatom 216 164 0 0 0 0 - - - 0;
#X floatatom 216 213 0 0 0 0 - - - 0;
#X floatatom 377 112 0 0 0 0 - - - 0;
#X floatatom 377 167 0 0 0 0 - - - 0;
#X floatatom 377 216 0 0 0 0 - - - 0;
#X obj 216 137 expr dbtorms($f1);
#X obj 216 189 expr rmstodb($f1);
#X obj 63 314 mtof;
#X obj 119 314 ftom;
#X obj 175 315 dbtorms;
#X obj 251 315 rmstodb;
#X obj 330 315 dbtopow;
#X obj 407 315 powtodb;
#X text 63 279 See also:;
#X obj 377 140 expr dbtopow($f1);
#X obj 377 192 expr powtodb($f1);
#X text 63 77 MTDI x Hertz;
#X text 79 33 Acoustic conversions;
#X text 238 81 dB x RMS;
#X text 396 82 dB x Power;
#X connect 0 0 3 0;
#X connect 1 0 4 0;
#X connect 3 0 1 0;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 12 0;
#X connect 8 0 20 0;
#X connect 9 0 21 0;
#X connect 11 0 6 0;
#X connect 12 0 7 0;
#X connect 20 0 9 0;
#X connect 21 0 10 0;
#X restore 124 460 pd Acoustics;
#N canvas 455 162 370 439 Logic-operators 0;
#X text 107 292 Logical Not;
#X obj 75 325 expr !$f1;
#X msg 75 71 0 0;
#X msg 90 98 1 0;
#X msg 101 128 0 1;
#X msg 109 159 1 1;
#X obj 75 227 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 75 194 expr $f1 && $f2;
#X msg 201 67 0 0;
#X msg 216 94 1 0;
#X msg 227 124 0 1;
#X msg 235 155 1 1;
#X obj 201 190 expr $f1 || $f2;
#X obj 201 325 expr !$f1;
#X obj 201 222 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 201 293 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 75 293 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 75 353 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 201 353 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X text 67 38 Logical And;
#X text 192 36 Logical Or;
#X connect 1 0 17 0;
#X connect 2 0 7 0;
#X connect 3 0 7 0;
#X connect 4 0 7 0;
#X connect 5 0 7 0;
#X connect 6 0 16 0;
#X connect 7 0 6 0;
#X connect 8 0 12 0;
#X connect 9 0 12 0;
#X connect 10 0 12 0;
#X connect 11 0 12 0;
#X connect 12 0 14 0;
#X connect 13 0 18 0;
#X connect 14 0 15 0;
#X connect 15 0 13 0;
#X connect 16 0 1 0;
#X restore 125 197 pd Logic-operators;
#N canvas 384 197 547 333 Relational-operators 0;
#X floatatom 48 55 5 0 0 0 - - - 0;
#X floatatom 48 110 5 0 0 0 - - - 0;
#X floatatom 199 54 5 0 0 0 - - - 0;
#X floatatom 199 109 5 0 0 0 - - - 0;
#X floatatom 55 194 5 0 0 0 - - - 0;
#X floatatom 55 259 5 0 0 0 - - - 0;
#X floatatom 351 58 5 0 0 0 - - - 0;
#X floatatom 351 113 5 0 0 0 - - - 0;
#X obj 48 82 expr $f1 > 4;
#X obj 199 81 expr $f1 < 4;
#X obj 55 226 expr $f1 >= 1;
#X text 207 26 Less than;
#X text 48 26 Greater than;
#X text 44 148 Greater than;
#X text 51 166 or equal;
#X floatatom 203 194 5 0 0 0 - - - 0;
#X floatatom 203 259 5 0 0 0 - - - 0;
#X text 206 167 or equal;
#X text 202 149 Less than;
#X obj 203 226 expr $f1 <= 10;
#X text 356 25 Equal;
#X obj 351 85 expr $f1 == 2;
#X floatatom 354 194 5 0 0 0 - - - 0;
#X floatatom 354 259 5 0 0 0 - - - 0;
#X text 350 157 Not Equal;
#X obj 354 226 expr $f1 != 2;
#X connect 0 0 8 0;
#X connect 2 0 9 0;
#X connect 4 0 10 0;
#X connect 6 0 21 0;
#X connect 8 0 1 0;
#X connect 9 0 3 0;
#X connect 10 0 5 0;
#X connect 15 0 19 0;
#X connect 19 0 16 0;
#X connect 21 0 7 0;
#X connect 22 0 25 0;
#X connect 25 0 23 0;
#X restore 125 167 pd Relational-operators;
#X restore 505 549 pd All_functions \; and operators;
#N canvas 341 56 961 640 [expr] 0;
#X obj 206 123 expr 1;
#X floatatom 206 153 4 0 0 0 - - - 0;
#X floatatom 307 151 4 0 0 0 - - - 0;
#X floatatom 52 383 0 0 0 0 - - - 12;
#X floatatom 557 45 6 0 0 0 - - - 0;
#X floatatom 557 125 5 0 0 0 - - - 0;
#X floatatom 573 344 0 0 0 0 - - - 0;
#X obj 573 316 expr 8 / 3;
#X floatatom 707 583 0 0 0 0 - - - 0;
#X floatatom 768 583 0 0 0 0 - - - 0;
#X obj 557 77 expr cos(2 * 3.14159 * $f1 / 360) \; sin(2 * 3.14159 * $f1 / 360);
#X floatatom 792 125 5 0 0 0 - - - 0;
#X floatatom 308 450 5 0 0 0 - - - 0;
#X floatatom 308 558 5 0 0 0 - - - 0;
#X floatatom 352 557 5 0 0 0 - - - 0;
#X floatatom 396 557 5 0 0 0 - - - 0;
#X obj 352 597 print expr;
#X obj 52 352 expr ($f1 + 2) * $i2;
#X text 71 111 A bang evaluates the expression, f 17;
#X text 609 44 example of trigonometric functions;
#X floatatom 793 345 0 0 0 0 - - - 0;
#X msg 793 293 8;
#X obj 793 317 expr $f1 / 3;
#X text 542 537 '8.' becomes a float =>;
#X floatatom 679 344 0 0 0 0 - - - 0;
#X msg 679 292 8;
#X obj 679 316 expr $i1 / 3;
#X text 508 210 Integer numbers inside the [expr] object are interpreted as integers \, not floats. Hence \, the result of the division below to the left is also an integer and it's the same if you have an '$i#' variable \, but '$f#' works fine.;
#X obj 707 521 expr float(8) / 3 \; (8.) / 3 \; 8./3;
#X floatatom 830 583 0 0 0 0 - - - 0;
#X text 542 551 also becomes a float =>;
#X obj 307 123 expr 2 + 3.2;
#X text 496 180 NOTE About integers and integer variable types:;
#X text 30 31 Here are some basic examples of the [expr] object. This object only takes the variables: "$f#" \, "$i#" and "$s#" (examples of this type are presented in [pd Arrays] in the parent patch)., f 63;
#X obj 157 316 t b f;
#X floatatom 52 289 6 0 0 0 - - - 0;
#X floatatom 157 289 6 0 0 0 - - - 0;
#X text 28 202 '$f1' is a float from the 1st inlet \, '$i2' is an integer from the second inlet (so float input values are truncated to integers).;
#X obj 308 486 expr $f1 + 1 \; $f1 - 1 \; $f1 * 2 + 1;
#X text 222 341 See how '()' is used to force an operation priority for the sum. Otherwise '*' and '/' have priority., f 33;
#X text 219 283 Note that a bang also evaluates the expression with the previously set values., f 34;
#X text 57 470 A semicolon can be used to create and separate different expressions (up to 100). If so \, an outlet is created for each expression and they're evaluated from right to left (or bottom to up) order:, f 30;
#X text 507 390 Pd turns "8.0" into "8" and [expr] will see it as an integer. One way to deal with this is with the "float" function to convert an integer to a float. A possible workaround is to have just a decimal point and the number inside parenthesis. Pd sees this as a symbol and doesn't remove the dot and [expr] will see it as a float. Other hacks like that are possible \, see below:, f 61;
#X obj 206 95 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 307 95 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 573 289 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 707 494 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X connect 0 0 1 0;
#X connect 4 0 10 0;
#X connect 7 0 6 0;
#X connect 10 0 5 0;
#X connect 10 1 11 0;
#X connect 12 0 38 0;
#X connect 13 0 16 0;
#X connect 14 0 16 0;
#X connect 15 0 16 0;
#X connect 17 0 3 0;
#X connect 21 0 22 0;
#X connect 22 0 20 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 28 0 8 0;
#X connect 28 1 9 0;
#X connect 28 2 29 0;
#X connect 31 0 2 0;
#X connect 34 0 17 0;
#X connect 34 1 17 1;
#X connect 35 0 17 0;
#X connect 36 0 34 0;
#X connect 38 0 13 0;
#X connect 38 1 14 0;
#X connect 38 2 15 0;
#X connect 43 0 0 0;
#X connect 44 0 31 0;
#X connect 45 0 7 0;
#X connect 46 0 28 0;
#X restore 226 500 pd [expr] Examples;
#N canvas 354 35 837 696 [expr~] 0;
#X floatatom 50 361 5 0 0 0 - - - 0;
#X obj 50 468 dac~;
#X text 95 361 frequency;
#X floatatom 743 257 7 0 10 0 - - - 0;
#X obj 536 328 tabsend~ a1;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a1 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 103 527 graph;
#X obj 546 458 tabsend~ a2;
#X obj 711 454 tabsend~ a3;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a2 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 319 528 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a3 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 540 528 graph;
#X obj 50 388 osc~ 440;
#X floatatom 250 347 8 0 0 0 - - - 0;
#X text 314 347 amplitude;
#X obj 250 399 line~;
#X obj 50 429 expr~ $v1 * pow($v2 / 127 \, 4);
#X obj 546 408 expr~ $v1 * $v2 \; if ($v2 > 0 \, 0 \, $v1*$v2);
#X obj 546 375 osc~ 440;
#X obj 536 251 osc~ 440;
#X obj 536 289 expr~ max(min($v1 \, $f2) \, -$f2);
#X text 518 186 Move the slider to change the limiter threshold (from 0-1)., f 29;
#X obj 147 299 print~;
#X floatatom 249 209 5 0 0 0 - - - 0;
#X floatatom 147 184 6 0 0 0 - - - 0;
#X obj 147 211 sig~ 1;
#X obj 711 375 osc~ 550;
#X text 516 162 A simple limiter/clip example:;
#X text 52 218 Examples:;
#X text 468 21 NOTE: The vector/block size can be set with the [block~] or [switch~] objects \, and is 64 samples by default., f 49;
#X msg 250 373 \$1 20;
#X obj 561 79 block~ 64;
#X text 486 79 see also:;
#X obj 147 239 expr~ $v1 + $v2;
#X text 22 105 Besides '$f#' \, '$i#' and '$s#' \, [expr~] takes '$v#' variables. Note that the first inlet of [expr~] needs to be of type '$v1'. You can still send floats to this left inlet as floats sent to audio inlets are promoted to signals., f 54;
#X msg 290 55 \; pd dsp \$1;
#X text 359 404 a semicolon also creates more expressions and outlets (up to 100), f 24;
#X text 58 33 make sure to turn on the audio for the [expr~] examples ----->, f 31;
#X obj 165 270 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 253 318 hsl 162 19 0 1 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 743 72 vsl 19 162 0 1 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 290 20 set-dsp-tgl;
#X text 321 24 DSP on/off;
#X connect 0 0 10 0;
#X connect 3 0 18 1;
#X connect 10 0 14 0;
#X connect 11 0 28 0;
#X connect 13 0 14 1;
#X connect 14 0 1 0;
#X connect 14 0 1 1;
#X connect 15 0 6 0;
#X connect 15 1 7 0;
#X connect 16 0 15 0;
#X connect 17 0 18 0;
#X connect 18 0 4 0;
#X connect 21 0 31 1;
#X connect 22 0 23 0;
#X connect 23 0 31 0;
#X connect 24 0 15 1;
#X connect 28 0 13 0;
#X connect 31 0 20 0;
#X connect 36 0 20 0;
#X connect 37 0 11 0;
#X connect 38 0 3 0;
#X connect 39 0 33 0;
#X restore 219 528 pd [expr~] Examples;
#N canvas 240 37 1094 690 [fexpr~] 0;
#X text 90 365 - $x1: same as $x1[0] \, $x2: same as $x2[0] (and so on)., f 60;
#X text 90 347 - $x: same as $x1[0]., f 60;
#X text 90 383 - $y: same as $y1[-1]., f 60;
#X text 90 401 - $y1: same as $y1[-1] \, $y2: same as $y2[-1] (and so on)., f 60;
#X msg 670 165 start;
#X msg 618 165 stop;
#X obj 618 135 loadbang;
#X msg 739 162 set 4000;
#X obj 726 128 sig~ 0.001;
#X obj 726 230 fexpr~ $x1[0] + $y1[-1];
#X msg 753 196 clear y1;
#X text 820 196 clears output buffer;
#X obj 726 268 snapshot~;
#X obj 590 220 metro 100;
#X obj 590 195 tgl 19 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000 0 1;
#X floatatom 726 293 8 0 0 0 - - - 0;
#X text 806 127 increment value;
#X text 804 161 set last output value ($y1[-1]);
#X text 83 605 - clear: clears all the previous input and output buffers, f 60;
#X text 83 569 - clear x#: clears the previous values of the #th input, f 60;
#X text 83 587 - clear y#: clears the previous values of the #th output, f 60;
#X text 83 490 - set y# <list>: sets the as many supplied values of the #th output (e.g. "set y3 1 2" sets $y3[-1] = 1 and $y3[-2] = 2).;
#X floatatom 816 517 5 0 0 0 - - - 0;
#X msg 617 483 start;
#X msg 571 483 stop;
#X obj 571 450 loadbang;
#X msg 777 479 0;
#X obj 672 553 fexpr~ $x1 + $x1[$f2];
#X msg 672 425 1102.5;
#X floatatom 672 483 7 0 0 0 - - - 0;
#X text 556 342 Simple FIR filter:, f 58;
#X msg 856 479 -20;
#X msg 816 479 -10;
#X text 754 433 change values to filter the frequencies, f 23;
#X text 83 523 - set <list>: sets the first past values of each output (e.g. "set 0.1 2.2 0.4" sets y1[-1] = 0.1 \, y2[-1] = 2.2 \, and y3[-1] = 0.4).;
#X text 83 458 - set x# <list>: sets as many supplied values of the #th input (e.g. "set x2 1 2" sets $x2[0] = 1 and $x2[-1] = 2)., f 60;
#X text 561 85 Simple accumulator example:;
#X text 49 433 [fexpr~] responds to the following methods:, f 63;
#X text 933 579 more examples:;
#X text 612 364 -10 offset filters audio at frequency of 2205 Hz -20 offset filters audio at frequency of 1102.5 Hz, f 50;
#X msg 689 452 2205;
#X obj 672 514 osc~ 2205;
#X text 24 26 NOTE: - [fexpr~] operates on sample level data for things like filter design and can be very cpu intensive!, f 69;
#X text 52 325 There are shorthands as follows:;
#X text 83 623 - stop: stops the computation of [fexpr~], f 60;
#X text 83 641 - start: starts the computation of [fexpr~], f 60;
#X text 558 18 As noted \, [fexpr~] can be CPU expensive! By default \, [fexpr~] is on when it is loaded \, but you can save CPU and control when it is on or off with the 'start' and 'stop' messages. Below \, you need to click 'start' to get it running., f 73;
#X msg 917 271 \; pd dsp \$1;
#X obj 672 600 output~;
#X obj 924 519 declare -stdpath ./;
#N canvas 695 185 533 408 fractional-sample-index 0;
#X msg 130 190 start;
#X msg 78 189 stop;
#X obj 78 158 loadbang;
#X floatatom 305 176 9 -10 0 0 - - - 0;
#X obj 305 233 line~;
#X msg 305 203 \$1 100;
#X obj 161 222 osc~ 2205;
#X text 209 128 fractional sample index offset, f 17;
#X obj 161 264 fexpr~ $x1 + $x1[$x2];
#X text 25 16 When fractional index offset is used for either input or output samples (with '$f#' or '$x#' variables) \, [fexpr~] determines the value by linear interpolation., f 63;
#X text 25 69 In the following example \, you can continuously change the sample input index from 0 to -10 (the point that filters the frequency of 2205 Hz)., f 63;
#X obj 161 314 output~;
#X obj 308 150 hsl 162 19 0 -10 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 4 0 8 1;
#X connect 5 0 4 0;
#X connect 6 0 8 0;
#X connect 8 0 11 0;
#X connect 12 0 3 0;
#X restore 854 605 pd fractional-sample-index;
#N canvas 286 64 900 597 difference-equations(Lorenz) 0;
#X obj 194 193 v pr;
#X obj 341 193 v r;
#X obj 249 195 v b;
#X floatatom 194 164 5 0 0 0 - - - 0;
#X floatatom 341 166 5 0 0 0 - - - 0;
#X msg 194 139 10;
#X msg 172 251 set 1.2 2.3 4.4;
#X floatatom 249 165 7 0 0 0 - - - 0;
#X floatatom 399 166 5 0 0 0 - - - 0;
#X obj 399 195 v dt;
#X msg 341 137 18;
#X msg 399 127 0.01;
#X obj 172 65 bng 25 250 50 0 empty empty empty 20 8 0 8 #dfdfdf #000000 #000000;
#X obj 449 136 line;
#X msg 449 110 0.01 \, 0.04 5000;
#X obj 101 193 loadbang;
#N canvas 0 50 450 300 (subpatch) 0;
#X array X 64 float 0;
#X coords 0 20 63 -20 200 140 1 0 0;
#X restore 178 423 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Y 64 float 0;
#X coords 0 20 63 -20 200 140 2 0 0;
#X restore 418 421 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Z 64 float 0;
#X coords 0 40 63 0 200 140 2 0 0;
#X restore 655 420 graph;
#X obj 249 136 expr 8./3;
#X text 587 289 $y1 -> $y1[-1] $y2 -> $y2[-1] $y3 -> $y3[-1], f 15;
#X text 145 547 -20;
#X text 152 416 20;
#X text 381 547 -20;
#X text 388 416 20;
#X text 635 547 0;
#X text 630 416 40;
#X text 624 24 Lorenz Equations written with 3 state variables X \, Y \, and Z:, f 30;
#X text 670 67 dX/dt = pr * (Y - X);
#X text 670 87 dY/dt = X(r - Z) - Y;
#X text 670 107 dZ/dt = X*Y - bZ, f 20;
#X obj 172 285 fexpr~ $y1 + pr*($y2 - $y1) * dt \; $y2 + ($y1*(r - $y3) - $y2) * dt \; $y3 + ($y1*$y2 - b*$y3) * dt;
#X obj 172 359 tabsend~ X;
#X obj 286 359 tabsend~ Y;
#X obj 400 360 tabsend~ Z;
#X msg 101 218 stop;
#X text 475 182 hear a click and audio stops \, the system went unstable and you need to bang on the top again to reload the default values., f 46;
#X msg 43 220 start;
#X obj 36 444 output~;
#X text 241 19 This is an example of how [fexpr~] can be used to solve differential equations such as the lorenz equations. Semicolons create new outlets as usual (up to 100). Here we have 3 expressions \, so we now have '$y2' and '$y3' variables., f 49;
#X text 412 301 <00 Note the shorthands:;
#X text 294 250 <-- sets initial values of $y1[-1] \, $y2[-1] \, and $y3[-1];
#X text 446 165 <-- experiment with these parameter values. If you;
#X text 98 52 bang to start -->, f 9;
#X connect 3 0 0 0;
#X connect 4 0 1 0;
#X connect 5 0 3 0;
#X connect 6 0 31 0;
#X connect 7 0 2 0;
#X connect 8 0 9 0;
#X connect 10 0 4 0;
#X connect 11 0 8 0;
#X connect 12 0 5 0;
#X connect 12 0 10 0;
#X connect 12 0 11 0;
#X connect 12 0 6 0;
#X connect 12 0 37 0;
#X connect 12 0 19 0;
#X connect 13 0 8 0;
#X connect 14 0 13 0;
#X connect 15 0 35 0;
#X connect 19 0 7 0;
#X connect 31 0 32 0;
#X connect 31 0 38 0;
#X connect 31 1 33 0;
#X connect 31 2 34 0;
#X connect 35 0 31 0;
#X connect 37 0 31 0;
#X restore 819 633 pd difference-equations(Lorenz);
#X obj 340 155 fexpr~ $x1[0] + $y1[-1];
#X text 62 193 'n' index for '$x#' is from 0 to minus "vector size - 1".;
#X text 62 210 'n' index for '$x#' is from -1 to minus "vector size - 1".;
#X text 23 63 Besides '$f#' \, '$i#' and '$s#' \, [fexpr~] takes '$x#' and '$y#' variables (and no '$v#' variables from [expr~]). Note that the first inlet of [fexpr~] needs to be of type '$x1' (cannot be '$f1' \, '$i1' or '$s1'). You can still send floats to this left inlet as floats sent to audio inlets are promoted to signals. The '$x#' and '$y#' types are input and output samples defined by 'n':, f 71;
#X text 23 243 The vector (or 'block') size is defined by the [block~] or [switch~] objects. The default is 64 so it's from 0 to -63 for '$x#' and -1 to -63 for $y#. As such \, $x#[0] specifies the current sample input \, and $y#[-1] the last sample output., f 72;
#X obj 917 234 set-dsp-tgl;
#X text 948 238 DSP on/off;
#X connect 4 0 9 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 6 0 14 0;
#X connect 7 0 9 0;
#X connect 8 0 9 0;
#X connect 9 0 12 0;
#X connect 10 0 9 0;
#X connect 12 0 15 0;
#X connect 13 0 12 0;
#X connect 14 0 13 0;
#X connect 22 0 27 1;
#X connect 23 0 27 0;
#X connect 24 0 27 0;
#X connect 25 0 24 0;
#X connect 26 0 22 0;
#X connect 27 0 48 0;
#X connect 28 0 29 0;
#X connect 29 0 41 0;
#X connect 31 0 22 0;
#X connect 32 0 22 0;
#X connect 40 0 29 0;
#X connect 41 0 27 0;
#X connect 57 0 47 0;
#X restore 212 555 pd [fexpr~] Examples;
#X obj 335 608 >;
#X text 102 522 (click on the subpatches to open them), f 13;
#X obj 387 671 random;
#N canvas 411 74 872 635 [value] 0;
#X floatatom 596 202 5 0 0 0 - - - 0;
#X obj 596 137 until;
#X msg 719 138 0;
#X obj 719 168 v i;
#X obj 596 169 expr i = i + 1;
#X msg 596 72 10;
#X obj 596 229 print;
#X obj 261 63 loadbang;
#X obj 221 176 value a;
#X obj 261 149 value b;
#X obj 304 123 value c;
#X obj 91 337 expr (a + b) / c;
#X floatatom 91 371 5 0 0 0 - - - 0;
#X obj 596 103 trigger float bang;
#X obj 697 288 expr i * 2 \; i = i + 1;
#X floatatom 697 334 5 0 0 0 - - - 0;
#X floatatom 771 335 5 0 0 0 - - - 0;
#X text 33 233 All you have to do is just use the variable name into the expression:, f 27;
#X obj 90 422 expr~ (a + b) / c;
#X obj 90 453 print~;
#X msg 221 97 5;
#X msg 261 97 3;
#X msg 304 97 2.5;
#X obj 91 533 print~;
#X obj 91 502 fexpr~ (a + b) / c;
#X obj 576 504 v last;
#X obj 450 535 fexpr~ last = $x1[-1] \; $x1[0] - last;
#X obj 601 590 print~;
#X obj 450 504 phasor~ 1000;
#X text 22 15 [expr] \, [expr~] and [fexpr~] can access variables set into [value] objects.;
#X text 471 14 It is also possible to assign values to variables inside the expr family of objects with "=" (a.k.a the "store function")., f 51;
#X text 294 395 You can also assign variables values in [expr~] and [fexpr~]. But it is not pertinent to do this in [expr~] because it deals with whole signal vectors and not single values. As for [fexpr~] \, note that they're evaluated in from top to bottom instead. This means you need to update a variable and call it in the below expression \, check the following example:, f 75;
#X obj 91 308 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 62 422 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 63 502 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 635 555 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 697 253 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 100 98 loading values into [value] objects ------->, f 16;
#X text 325 291 Expressions are output from right to left order in [expr] \, since they're evaluated from bottom to top. This means you need to update a variable and call it in the above expression \, check it ------------->, f 51;
#X connect 0 0 6 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 4 0 0 0;
#X connect 5 0 13 0;
#X connect 7 0 21 0;
#X connect 7 0 22 0;
#X connect 7 0 20 0;
#X connect 11 0 12 0;
#X connect 13 0 1 0;
#X connect 13 1 2 0;
#X connect 14 0 15 0;
#X connect 14 1 16 0;
#X connect 18 0 19 0;
#X connect 20 0 8 0;
#X connect 21 0 9 0;
#X connect 22 0 10 0;
#X connect 24 0 23 0;
#X connect 26 1 27 0;
#X connect 28 0 26 0;
#X connect 32 0 11 0;
#X connect 33 0 19 0;
#X connect 34 0 23 0;
#X connect 35 0 27 0;
#X connect 36 0 14 0;
#X restore 580 497 pd [value];
#X obj 105 258 expr $f1 + $s3[$i2];
#X symbolatom 235 232 7 0 0 0 - - - 0;
#X floatatom 170 231 3 0 0 0 - - - 0;
#X floatatom 105 232 4 0 0 0 - - - 0;
#X obj 278 329 sig~ 1;
#X obj 74 451 fexpr~ $x1[0] + $y1[-1];
#X text 62 297 [expr~] has an exclusive input variable defined as '$v#' - which stands for an audio signal 'vector' (or block)., f 85;
#X text 49 395 [fexpr~] has exclusive variable types defined as: '$x#[n]' (an input audio sample from inlet # indexed by 'n') and '$y#[n]' (an output audio sample from outlet # indexed by 'n')., f 91;
#X text 307 224 First inlet is a float input that adds to an array value whose index is defined by an integer input from the second inlet and the third inlet takes a symbol for the array name., f 50;
#X obj 441 671 array;
#X obj 278 355 expr~ $v1 + $f2;
#X floatatom 401 355 5 0 0 0 - - - 0;
#X obj 242 671 cos~;
#X text 51 147 These objects have several built in operators and functions and the syntax is quite similar to how expressions are written in C. They receive input variables via the inlets and understand the variable types: '$f#' (floats) \, '$i#' (integers) and '$s#' (symbols \, used to represent array names) - '#' is the inlet number (up to 100) as below:, f 88;
#X text 518 670 updated for Pd version 0.51-3;
#X obj 70 33 expr;
#X obj 63 58 expr~;
#X obj 57 96 fexpr~;
#X text 26 3 Expression evaluation family of objects By Shahrokh Yadegari - Version 0.57, f 75;
#X text 107 96 - evaluation of audio signal expressions;
#X text 107 58 - evaluation of audio signal expressions;
#X text 107 33 - evaluation of control data expressions;
#X text 121 76 on a vector by vector basis, f 38;
#X text 121 113 on a sample by sample basis, f 38;
#X obj 7 137 cnv 1 730 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X obj 451 57 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#N canvas 798 148 456 264 reference 0;
#X obj 101 59 inlet;
#X obj 101 190 pdcontrol;
#X obj 101 130 pdcontrol;
#X msg 101 105 dir;
#X text 205 94 this window opens the html reference link via the [pdcontrol] object., f 25;
#X msg 101 159 browse \$1/../8.topics/expr.htm;
#X connect 0 0 3 0;
#X connect 2 0 5 0;
#X connect 3 0 2 0;
#X connect 5 0 1 0;
#X restore 451 91 pd reference;
#X obj 8 595 cnv 1 730 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 655 90 <= click;
#N canvas 705 69 573 527 reference 0;
#X obj 9 43 cnv 5 550 5 empty empty INLETS: 8 18 0 13 #202020 #000000 0;
#X obj 9 258 cnv 2 550 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000 0;
#X obj 9 347 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 8 498 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 8 178 cnv 1 550 1 empty empty 'n': 8 12 0 13 #7c7c7c #000000 0;
#X obj 22 10 expr;
#X text 82 52 (arguments set 'n' number of inlets and type);
#X text 77 201 symbol - if inlet type is '$s#' or '$i#'., f 44;
#X obj 8 291 cnv 1 550 1 empty empty 'n': 8 12 0 13 #7c7c7c #000000 0;
#X text 83 263 (number of expressions define 'n' numbers of outlets);
#X text 12 374 1) list -;
#X obj 62 10 expr~;
#X obj 110 10 fexpr~;
#X text 100 298 float - (for [expr] only) expression result., f 58;
#X text 93 317 signal - (for [expr~] and [fexpr~] only) expression result.;
#X text 164 9 - expression evaluation family of objects.;
#X text 77 219 signal -;
#X text 140 219 if inlet type is '$v#' ([expr~]) or '$x#' ([fexpr~]) \, leftmost inlet is always signal in [expr~]/[fexpr~].;
#X obj 8 78 cnv 1 550 1 empty empty leftmost: 8 12 0 13 #7c7c7c #000000 0;
#X text 32 139 clear <symbol> -;
#X text 102 83 bang - in [expr]: evaluate expression., f 64;
#X text 60 101 set <list> - in [fexpr~]: set values for previous input/output values., f 70;
#X text 60 119 stop/start - in [fexpr~]: stop/start computation., f 70;
#X text 151 139 in [fexpr~]: clear input/output memory \, optional symbol specifies a specific input (such as x1) or output (y1)., f 57;
#X text 84 183 float - if inlet type is '$f#' or '$i#' ('#' is inlet number)., f 62;
#X text 83 374 expression including operators \, functions \, inlet types \, float and symbols (for array names and variables). See html reference and examples for all operators and functions. Semicolons create more expressions (and outlets). Inlet type has the format '$t#' - where 't' is type (f \, i \, s \, v and x) and # is the inlet number \, fexpr~'s 'x' type also has a sample number inside brackets and fexpr~ also has a 'y' variable for output samples with previous samples inside brackets as well (default: output zeros)., f 66;
#X restore 561 91 pd reference;
#X text 338 328 <-- 1st inlet is an audio signal vector/block;
#X text 256 443 'n' index for '$x#' is from 0 to minus "vector size - 1".;
#X text 256 460 'n' index for '$x#' is from -1 to minus "vector size - 1".;
#X text 474 57 <-- Open HTML reference;
#X obj 24 671 abs;
#X obj 55 671 abs~;
#X text 93 670 - unary operators;
#X obj 111 608 +;
#X text 174 607 - binary operators;
#X obj 144 608 +~;
#X obj 24 637 mtof;
#X obj 62 638 mtof~;
#X text 105 637 - acoustic conversions;
#X obj 335 638 sin;
#X text 366 607 - other binary operators (control only);
#X text 364 637 - trigonometric functions (control only);
#X connect 16 0 15 2;
#X connect 17 0 15 1;
#X connect 18 0 15 0;
#X connect 19 0 25 0;
#X connect 26 0 25 1;
#X connect 40 0 41 0;
