#N canvas 423 57 745 701 12;
#X declare -stdpath ./;
#N canvas 455 177 911 525 Arrays 0;
#X floatatom 123 393 4 0 9 0 - - - 0;
#X floatatom 123 457 10 0 0 0 - - - 0;
#X obj 123 429 expr $s2[$f1];
#X floatatom 112 94 5 0 9 0 - - - 0;
#X floatatom 112 170 9 0 0 0 - - - 0;
#X text 55 56 For instance:;
#X obj 211 342 loadbang;
#X floatatom 502 232 8 0 100 0 - - - 0;
#X text 28 281 A symbol inlet - defined as '$s#' (# being the inlet number) - is used to receive the array names., f 55;
#X text 573 218 [expr] can set values to an array index with "=" (a.k.a. "store function") as in:, f 41;
#X text 27 210 Note that variables '$f#' are also possible as the array index \, but it won't make sense since there's no interpolation and float inputs are just truncated to integers., f 55;
#X msg 211 368 symbol array100;
#X obj 112 131 expr array100[$i1];
#X obj 502 263 expr array100[1] = $f1;
#X obj 660 403 expr~ $v1 + array100[1];
#X obj 660 430 fexpr~ $x1 + array100[1];
#X obj 502 46 vsl 19 162 0 10 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X text 154 93 <-- index to read from the array, f 33;
#X obj 577 30 cnv 19 218 128 empty empty empty 20 12 0 12 #ffffff #404040 0;
#X obj 577 30 cnv 19 218 128 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array array100 10 float 1;
#A 0 1 5.59006 2 8 5 6 1 4 2 8;
#X coords 0 10 9 0 220 130 1 0 0;
#X restore 576 29 graph;
#X text 48 17 [expr] \, [expr~] and [fexpr~] can read values from arrays (without interpolation). The syntax is arrayname[index].;
#X text 516 325 Even though you can also use arrays in [expr~] and [fexpr~]. They cannot write values to arrays and the index values cannot be audio variables (just either '$i#' or '$f#')., f 39;
#X symbolatom 211 396 10 0 0 0 - - - 0;
#X connect 0 0 2 0;
#X connect 2 0 1 0;
#X connect 3 0 12 0;
#X connect 6 0 11 0;
#X connect 7 0 13 0;
#X connect 11 0 23 0;
#X connect 12 0 4 0;
#X connect 16 0 7 0;
#X connect 23 0 2 1;
#X restore 505 489 pd Arrays;
#X text 88 499 Basic examples:;
#X text 429 513 Further details:, f 8;
#N canvas 350 134 854 610 Dealing_with_"\$0" 0;
#X obj 596 142 expr $s2[$f1];
#X obj 684 111 symbol \$0-x;
#X floatatom 596 116 5 0 99 0 - - - 0;
#X floatatom 596 170 5 0 0 0 - - - 0;
#X obj 684 88 loadbang;
#X obj 298 464 expr \$0-x[$f1];
#X floatatom 298 430 5 0 99 0 - - - 0;
#X floatatom 298 500 5 0 0 0 - - - 0;
#X obj 676 375 value x\$0;
#X obj 712 347 value y_\$0;
#X obj 556 328 expr x\$0 \; y_\$0;
#X msg 676 348 1.3;
#X msg 712 321 4.7;
#X obj 676 288 loadbang;
#X floatatom 616 377 5 0 0 0 - - - 0;
#X floatatom 556 377 5 0 0 0 - - - 0;
#X text 508 221 A simpler practice that will always work for both table names and variables is to just have '\$0' after a symbol character \, such as:, f 41;
#X text 33 211 On the other hand \, the '-' character is used for the subtraction operator. Thus \, '\$0-x' is interpreted as "ID number" minus 'x' in the [expr] object below and not as the array name to the right., f 27;
#X text 74 428 This does load the object even though "\$0-x" doesn't correspond to the array name. But see how the Pd window gives an error that it can't find the 'x' table when trying to produce an output., f 26;
#X text 503 15 A solution for such array name issues is to send the table name as a symbol input. But this doesn't deal with variable names as they can't be loaded as symbols!, f 43;
#X text 297 525 error;
#X text 642 172 (works);
#X text 21 100 But it is important to note the restrictions of adopting the C-style expression syntax \, where symbols cannot start with a number \, so '\$0x' or '\$0_x' are illegal as Pd turns '\$0' into a number and thus the object won't load giving a syntax error!, f 62;
#X obj 556 297 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 510 115 try now -->;
#X text 340 429 <-- try;
#X text 21 17 '\$0' - the patch ID number used to force locality in Pd - may be used in the definition local array names in [expr] \, [expr~] or [fexpr~]. You can also use it to set local variable names in value objects that are retrieved in [expr] \, [expr~] and [fexpr~]. This is especially useful in abstractions., f 62;
#X obj 250 200 cnv 19 198 148 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-x 100 float 1;
#A 0 -0.720016 -0.706683 -0.693349 -0.680016 -0.666682 -0.653348 -0.640015 -0.625014 -0.610014 -0.595014 -0.580013 -0.565013 -0.550013 -0.535012 -0.520012 -0.505012 -0.490011 -0.475011 -0.460011 -0.44501 -0.43001 -0.415009 -0.400009 -0.385009 -0.370008 -0.355008 -0.340008 -0.325007 -0.310007 -0.295007 -0.280006 -0.264006 -0.248006 -0.232005 -0.216005 -0.200005 -0.184004 -0.168004 -0.152003 -0.136003 -0.120003 -0.106669 -0.0933355 -0.0800018 -0.0666682 -0.0533346 -0.0400009 -0.0266673 -0.0133336 -3.10441e-10 0.0133336 0.0266673 0.0400009 0.0533346 0.0666682 0.0800018 0.0933355 0.106669 0.120003 0.133336 0.14667 0.160004 0.173337 0.186671 0.200005 0.213338 0.226672 0.240005 0.253339 0.266673 0.280006 0.29715 0.314293 0.331436 0.348579 0.365723 0.382866 0.400009 0.413343 0.426676 0.44001 0.453344 0.466677 0.480011 0.500011 0.520012 0.540012 0.560013 0.570013 0.580013 0.590014 0.600014 0.620014 0.640015 0.660015 0.680016 0.680016 0.720016 0.720016 0.720016;
#X coords 0 1 99 -1 200 150 1 0 0;
#X restore 249 199 graph;
#X obj 564 536 v \$0-y;
#X obj 643 518 expr var("\$0-y");
#X floatatom 564 506 5 0 0 0 - - - 0;
#X floatatom 643 552 5 0 0 0 - - - 0;
#X obj 643 484 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 524 420 Note however that you can use the var() function to load a string that uses \$0 in any way you desire., f 39;
#X connect 0 0 3 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 4 0 1 0;
#X connect 5 0 7 0;
#X connect 6 0 5 0;
#X connect 10 0 15 0;
#X connect 10 1 14 0;
#X connect 11 0 8 0;
#X connect 12 0 9 0;
#X connect 13 0 11 0;
#X connect 13 0 12 0;
#X connect 23 0 10 0;
#X connect 30 0 32 0;
#X connect 31 0 29 0;
#X connect 33 0 30 0;
#X restore 505 518 pd Dealing_with_"\$0";
#X text 9 636 see also:;
#X obj 181 667 block~;
#X obj 236 667 value;
#N canvas 808 103 454 604 All_functions 0;
#N canvas 497 97 374 326 Arithmetic-operators 0;
#X obj 57 90 expr $f1 + 4;
#X floatatom 57 63 5 0 0 0 - - - 0;
#X floatatom 57 118 5 0 0 0 - - - 0;
#X floatatom 208 63 5 0 0 0 - - - 0;
#X floatatom 208 118 5 0 0 0 - - - 0;
#X obj 208 90 expr $f1 * 4;
#X floatatom 57 197 5 0 0 0 - - - 0;
#X floatatom 57 252 5 0 0 0 - - - 0;
#X floatatom 208 197 5 0 0 0 - - - 0;
#X floatatom 208 252 5 0 0 0 - - - 0;
#X obj 57 224 expr $f1 - 1;
#X obj 208 224 expr $f1 / 10;
#X text 57 34 Add;
#X text 206 34 Multiply;
#X text 206 174 Divide;
#X text 56 174 Subtract;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 3 0 5 0;
#X connect 5 0 4 0;
#X connect 6 0 10 0;
#X connect 8 0 11 0;
#X connect 10 0 7 0;
#X connect 11 0 9 0;
#X restore 130 176 pd Arithmetic-operators;
#N canvas 379 126 621 391 Bitwise-operators 0;
#X floatatom 47 328 5 0 0 0 - - - 0;
#X obj 47 294 expr ~ $f1;
#X floatatom 44 103 5 0 0 0 - - - 0;
#X obj 44 71 expr $f1 & 3;
#X floatatom 44 37 5 0 0 0 - - - 0;
#X text 104 36 Bitwise And;
#X floatatom 347 103 5 0 0 0 - - - 0;
#X floatatom 347 37 5 0 0 0 - - - 0;
#X obj 347 71 expr $f1 << 1;
#X floatatom 349 214 5 0 0 0 - - - 0;
#X floatatom 349 148 5 0 0 0 - - - 0;
#X text 404 147 Bitshift Right;
#X text 413 36 Bitshift Left;
#X obj 349 181 expr $f1 >> 2;
#X floatatom 353 328 5 0 0 0 - - - 0;
#X floatatom 353 258 5 0 0 0 - - - 0;
#X obj 353 294 expr $f1 ^ 1;
#X text 409 257 Bitwise Exclusive Or;
#X floatatom 47 214 5 0 0 0 - - - 0;
#X floatatom 47 148 5 0 0 0 - - - 0;
#X text 109 147 Bitwise Or;
#X obj 47 181 expr $f1 | 3;
#X floatatom 47 258 5 0 0 0 - - - 0;
#X text 97 257 Bitwise Not;
#X text 141 293 (one's complement);
#X connect 1 0 0 0;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 7 0 8 0;
#X connect 8 0 6 0;
#X connect 10 0 13 0;
#X connect 13 0 9 0;
#X connect 15 0 16 0;
#X connect 16 0 14 0;
#X connect 19 0 21 0;
#X connect 21 0 18 0;
#X connect 22 0 1 0;
#X restore 130 263 pd Bitwise-operators;
#N canvas 458 88 472 464 If-function 0;
#X floatatom 82 53 5 0 0 0 - - - 0;
#X floatatom 82 112 5 0 0 0 - - - 0;
#X floatatom 87 218 5 0 0 0 - - - 0;
#X floatatom 87 277 5 0 0 0 - - - 0;
#X text 142 213 if(condition \, true \, false);
#X obj 87 246 expr if($f1 > 0 \, $f1 * 10 \, $f1 - 1);
#X floatatom 59 346 5 0 0 0 - - - 0;
#X floatatom 59 405 5 0 0 0 - - - 0;
#X obj 59 374 expr if($f1 > 10 \, 10 \, if($f1 < -10 \, -10 \, $f1));
#X text 118 404 <= clips at -10 and 10;
#X obj 82 81 expr if($f1 >= 0 \, 1 \, -1);
#X text 53 21 Syntax: if(condition \, true \, false);
#X text 143 325 You can also nest an if function as a true/false expression:, f 32;
#X text 39 163 It accepts expressions as true/false as well:;
#X connect 0 0 10 0;
#X connect 2 0 5 0;
#X connect 5 0 3 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 10 0 1 0;
#X restore 130 292 pd If-function;
#N canvas 444 91 443 422 Random-function 0;
#X floatatom 107 187 5 0 0 0 - - - 0;
#X obj 107 156 expr random(10 \, 20);
#X text 130 125 random values from 10 to 19;
#X floatatom 108 287 5 0 0 0 - - - 0;
#X obj 108 256 expr random(-100 \, 101);
#X text 133 228 random values from -100 to 100;
#X text 36 32 The random function generates random numbers within a given range \, specified by the two arguments. The range is from the first argument to the second argument minus one., f 51;
#X obj 107 125 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 108 228 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 54 325 Unlike other pseudo number generators in Pd \, you cannot set a seed value., f 49;
#X text 57 375 see also:;
#X obj 131 375 random;
#X obj 189 375 noise~;
#X obj 247 375 array random;
#X connect 1 0 0 0;
#X connect 4 0 3 0;
#X connect 7 0 1 0;
#X connect 8 0 4 0;
#X restore 130 321 pd Random-function;
#N canvas 454 149 604 538 Table-functions 0;
#X floatatom 63 163 0 0 0 0 - - - 0;
#X floatatom 145 164 8 0 0 0 - - - 0;
#X floatatom 228 164 4 0 0 0 - - - 0;
#X obj 63 102 expr Sum("table" \, 3 \, 9) \; sum("table") \; size("table");
#X msg 402 413 symbol table;
#X floatatom 402 476 5 0 0 0 - - - 0;
#X text 54 187 Sums a range of indexes, f 8;
#X text 143 189 Sums all indexes, f 8;
#X text 225 189 Gives array size, f 5;
#X floatatom 47 344 8 0 0 0 - - - 0;
#X floatatom 240 344 8 0 0 0 - - - 0;
#X floatatom 47 469 0 0 0 0 - - - 0;
#X floatatom 212 467 0 0 0 0 - - - 0;
#X obj 47 299 expr avg("table") \; sum("table") / size("table");
#X obj 47 424 expr Avg("table" \, 3 \, 9) \; Sum("table" \, 3 \, 9) / 7;
#X text 73 267 avg - Averages all indexes;
#X text 72 396 Avg - averages a range of indexes;
#X text 127 26 There are 5 functions that operate on arrays: Avg \, avg \, Sum \, sum and size., f 45;
#X obj 63 73 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 47 269 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 47 396 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 339 87 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array table 100 float 1;
#A 0 0 1 2 3 4 5 6 7 8 9 18.5714 21.4285 28.5713 31.4284 34.9998 38.5712 40.714 42.8569 46.4283 49.2854 50.3568 51.4282 53.5711 54.2853 54.9996 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.5353 55.3568 55.1782 54.9996 54.2853 53.5711 52.8568 52.1425 51.4282 49.9997 48.5711 47.1426 45.714 44.0473 42.3807 40.714 39.0474 37.3807 35.7141 32.857 31.4284 29.9999 28.5713 26.4285 26.4285 26.7856 27.1427 27.857 28.5713 29.107 29.6427 30.1784 30.7141 31.607 32.4998 33.3927 34.2855 34.9998 35.7141 36.6665 37.6188 38.5712 40.714 41.4283 42.1426 44.2854 45.714 46.7854 47.8568 49.9997 51.4282 52.8568 55.7139 57.8567 59.9996 62.8567 64.9995 66.4281 69.2852 72.1423 93 94 95 96 97 98 99;
#X coords 0 100 99 0 200 140 1 0 0;
#X restore 338 87 graph;
#X obj 402 443 expr size($s1) \;;
#X text 343 248 You can use a symbol type to specify the array name via the inlet. Up to [expr] version 0.57 symbol types had to be put in double quotes (as in "$s1"). In [expr] versions 0.58 and up this has been deprecated and is no longer the case. It still works but a warning is given for you to remove the quotes., f 32;
#X connect 3 0 0 0;
#X connect 3 1 1 0;
#X connect 3 2 2 0;
#X connect 4 0 23 0;
#X connect 13 0 9 0;
#X connect 13 1 10 0;
#X connect 14 0 11 0;
#X connect 14 1 12 0;
#X connect 18 0 3 0;
#X connect 19 0 13 0;
#X connect 20 0 14 0;
#X connect 23 0 5 0;
#X restore 130 524 pd Table-functions;
#N canvas 286 64 570 578 Power-functions 0;
#X floatatom 62 60 5 0 0 0 - - - 0;
#X floatatom 62 119 5 0 0 0 - - - 0;
#X floatatom 62 151 5 0 0 0 - - - 0;
#X floatatom 62 208 5 0 0 0 - - - 0;
#X floatatom 59 337 5 0 0 0 - - - 0;
#X floatatom 59 409 0 0 0 0 - - - 0;
#X floatatom 306 103 5 0 0 0 - - - 0;
#X floatatom 394 101 5 0 0 0 - - - 0;
#X floatatom 306 31 5 0 0 0 - - - 0;
#X floatatom 308 414 5 0 0 0 - - - 0;
#X floatatom 308 484 0 0 0 0 - - - 0;
#X floatatom 62 513 5 0 0 0 - - - 0;
#X obj 62 88 expr pow($f1 \, 2);
#X floatatom 306 276 5 0 0 0 - - - 0;
#X floatatom 306 224 5 0 0 0 - - - 0;
#X obj 306 56 expr ln($f1) \; log($f1);
#X obj 62 484 expr fact($f1);
#X msg 62 451 3;
#X floatatom 403 482 0 0 0 0 - - - 0;
#X floatatom 154 408 0 0 0 0 - - - 0;
#X floatatom 307 187 5 0 0 0 - - - 0;
#X floatatom 307 135 5 0 0 0 - - - 0;
#X obj 307 160 expr log1p($f1);
#X obj 306 249 expr log10($f1);
#X floatatom 309 375 5 0 0 0 - - - 0;
#X floatatom 309 323 5 0 0 0 - - - 0;
#X obj 309 348 expr ldexp($f1 \, 3);
#X obj 59 365 expr exp($f1) \; expm1($f1);
#X floatatom 61 239 5 0 0 0 - - - 0;
#X floatatom 61 296 5 0 0 0 - - - 0;
#X obj 62 179 expr sqrt($f1);
#X obj 61 267 expr cbrt($f1);
#X text 171 382 exp - 1;
#X text 235 507 error function;
#X text 402 505 complementary error function, f 14;
#X obj 308 442 expr erf($f1) \; erfc($f1);
#X text 64 33 Raise to the power of;
#X text 129 148 Square root;
#X text 138 239 Cube root;
#X text 121 324 Exp: 'e' raised to the power of, f 15;
#X text 98 451 Factorial;
#X text 353 29 Natural log;
#X text 365 133 Natural log of input + 1;
#X text 353 221 Log base 10;
#X text 364 307 Multiply by integral power of 2, f 20;
#X text 368 409 Error functions;
#X text 112 54 second argument;
#X connect 0 0 12 0;
#X connect 2 0 30 0;
#X connect 4 0 27 0;
#X connect 8 0 15 0;
#X connect 9 0 35 0;
#X connect 12 0 1 0;
#X connect 14 0 23 0;
#X connect 15 0 6 0;
#X connect 15 1 7 0;
#X connect 16 0 11 0;
#X connect 17 0 16 0;
#X connect 21 0 22 0;
#X connect 22 0 20 0;
#X connect 23 0 13 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 27 0 5 0;
#X connect 27 1 19 0;
#X connect 28 0 31 0;
#X connect 30 0 3 0;
#X connect 31 0 29 0;
#X connect 35 0 10 0;
#X connect 35 1 18 0;
#X restore 130 350 pd Power-functions;
#N canvas 241 137 849 422 Trigonometric-functions 0;
#X floatatom 34 54 5 0 0 0 - - - 0;
#X floatatom 34 145 5 0 0 0 - - - 0;
#X floatatom 33 233 5 0 0 0 - - - 0;
#X obj 34 82 expr sin($f1);
#X obj 34 173 expr cos($f1);
#X obj 33 261 expr tan($f1);
#X floatatom 194 54 5 0 0 0 - - - 0;
#X floatatom 194 145 5 0 0 0 - - - 0;
#X obj 194 82 expr asin($f1);
#X obj 194 173 expr acos($f1);
#X text 83 52 sine;
#X text 85 145 cosine;
#X text 84 233 tangent;
#X floatatom 195 229 5 0 0 0 - - - 0;
#X text 261 52 arc sine;
#X text 256 145 arc cosine;
#X text 256 229 arc tangent;
#X floatatom 387 53 5 0 0 0 - - - 0;
#X floatatom 387 144 5 0 0 0 - - - 0;
#X floatatom 388 228 5 0 0 0 - - - 0;
#X floatatom 264 329 5 0 0 0 - - - 0;
#X floatatom 264 386 10 0 0 0 - - - 0;
#X obj 264 357 expr atan2($f1 \, $f2);
#X floatatom 401 329 5 0 0 0 - - - 0;
#X obj 195 257 expr atan($f1);
#X floatatom 617 53 5 0 0 0 - - - 0;
#X floatatom 617 144 5 0 0 0 - - - 0;
#X floatatom 618 228 5 0 0 0 - - - 0;
#X text 741 66 inverse hyperbolic sine, f 10;
#X obj 617 81 expr asinh($f1);
#X obj 617 172 expr acosh($f1);
#X obj 618 256 expr atanh($f1);
#X text 742 157 inverse hyperbolic cosine, f 10;
#X text 743 245 inverse hyperbolic tangent, f 10;
#X obj 387 81 expr sinh($f1);
#X obj 387 172 expr cosh($f1);
#X obj 388 256 expr tanh($f1);
#X text 503 255 hyperbolic tangent, f 10;
#X text 502 167 hyperbolic cosine, f 10;
#X text 501 76 hyperbolic sine, f 10;
#X text 112 12 All trigonometric functions expect the input in radians (except the arc or inverse ones)., f 89;
#X floatatom 618 285 10 0 0 0 - - - 0;
#X floatatom 33 290 10 0 0 0 - - - 0;
#X floatatom 195 286 10 0 0 0 - - - 0;
#X floatatom 388 285 10 0 0 0 - - - 0;
#X floatatom 34 202 10 0 0 0 - - - 0;
#X floatatom 194 202 10 0 0 0 - - - 0;
#X floatatom 387 201 10 0 0 0 - - - 0;
#X floatatom 617 201 10 0 0 0 - - - 0;
#X floatatom 34 113 10 0 0 0 - - - 0;
#X floatatom 194 113 10 0 0 0 - - - 0;
#X floatatom 387 112 10 0 0 0 - - - 0;
#X floatatom 617 112 10 0 0 0 - - - 0;
#X text 308 327 y;
#X text 444 328 x;
#X text 426 357 arc tangent of 2 coordinates (y-vertical / x-horizontal), f 28;
#X connect 0 0 3 0;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 3 0 49 0;
#X connect 4 0 45 0;
#X connect 5 0 42 0;
#X connect 6 0 8 0;
#X connect 7 0 9 0;
#X connect 8 0 50 0;
#X connect 9 0 46 0;
#X connect 13 0 24 0;
#X connect 17 0 34 0;
#X connect 18 0 35 0;
#X connect 19 0 36 0;
#X connect 20 0 22 0;
#X connect 22 0 21 0;
#X connect 23 0 22 1;
#X connect 24 0 43 0;
#X connect 25 0 29 0;
#X connect 26 0 30 0;
#X connect 27 0 31 0;
#X connect 29 0 52 0;
#X connect 30 0 48 0;
#X connect 31 0 41 0;
#X connect 34 0 51 0;
#X connect 35 0 47 0;
#X connect 36 0 44 0;
#X restore 130 379 pd Trigonometric-functions;
#N canvas 365 241 592 281 Store-function 0;
#X text 40 26 The store function is defined with "=" \, and it can store the result of any operation into a variable or table index.;
#X floatatom 62 211 5 0 0 0 - - - 0;
#X floatatom 276 211 5 0 0 0 - - - 0;
#X obj 62 158 expr array2[inc - 1] = 1 / inc \; inc = inc + 1;
#X obj 129 119 v inc;
#X msg 129 94 0;
#X obj 62 129 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 352 101 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array array2 16 float 2;
#X coords 0 1.1 16 -0.1 200 140 1 0 0;
#X restore 351 101 graph;
#X connect 3 0 1 0;
#X connect 3 1 2 0;
#X connect 5 0 4 0;
#X connect 6 0 3 0;
#X restore 130 495 pd Store-function;
#X text 41 113 These are organized in different groups. Click on the subpatches below to check each group:;
#N canvas 455 162 370 439 Logic-operators 0;
#X text 107 292 Logical Not;
#X obj 75 325 expr !$f1;
#X msg 75 71 0 0;
#X msg 90 98 1 0;
#X msg 101 128 0 1;
#X msg 109 159 1 1;
#X obj 75 227 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 75 194 expr $f1 && $f2;
#X msg 201 67 0 0;
#X msg 216 94 1 0;
#X msg 227 124 0 1;
#X msg 235 155 1 1;
#X obj 201 190 expr $f1 || $f2;
#X obj 201 325 expr !$f1;
#X obj 201 222 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 201 293 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 75 293 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 75 353 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 201 353 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X text 67 38 Logical And;
#X text 192 36 Logical Or;
#X connect 1 0 17 0;
#X connect 2 0 7 0;
#X connect 3 0 7 0;
#X connect 4 0 7 0;
#X connect 5 0 7 0;
#X connect 6 0 16 0;
#X connect 7 0 6 0;
#X connect 8 0 12 0;
#X connect 9 0 12 0;
#X connect 10 0 12 0;
#X connect 11 0 12 0;
#X connect 12 0 14 0;
#X connect 13 0 18 0;
#X connect 14 0 15 0;
#X connect 15 0 13 0;
#X connect 16 0 1 0;
#X restore 130 234 pd Logic-operators;
#N canvas 384 197 547 333 Relational-operators 0;
#X floatatom 48 55 5 0 0 0 - - - 0;
#X floatatom 48 110 5 0 0 0 - - - 0;
#X floatatom 199 54 5 0 0 0 - - - 0;
#X floatatom 199 109 5 0 0 0 - - - 0;
#X floatatom 55 194 5 0 0 0 - - - 0;
#X floatatom 55 259 5 0 0 0 - - - 0;
#X floatatom 351 58 5 0 0 0 - - - 0;
#X floatatom 351 113 5 0 0 0 - - - 0;
#X obj 48 82 expr $f1 > 4;
#X obj 199 81 expr $f1 < 4;
#X obj 55 226 expr $f1 >= 1;
#X text 207 26 Less than;
#X text 48 26 Greater than;
#X text 44 148 Greater than;
#X text 51 166 or equal;
#X floatatom 203 194 5 0 0 0 - - - 0;
#X floatatom 203 259 5 0 0 0 - - - 0;
#X text 206 167 or equal;
#X text 202 149 Less than;
#X obj 203 226 expr $f1 <= 10;
#X text 356 25 Equal;
#X obj 351 85 expr $f1 == 2;
#X floatatom 354 194 5 0 0 0 - - - 0;
#X floatatom 354 259 5 0 0 0 - - - 0;
#X text 350 157 Not Equal;
#X obj 354 226 expr $f1 != 2;
#X connect 0 0 8 0;
#X connect 2 0 9 0;
#X connect 4 0 10 0;
#X connect 6 0 21 0;
#X connect 8 0 1 0;
#X connect 9 0 3 0;
#X connect 10 0 5 0;
#X connect 15 0 19 0;
#X connect 19 0 16 0;
#X connect 21 0 7 0;
#X connect 22 0 25 0;
#X connect 25 0 23 0;
#X restore 130 205 pd Relational-operators;
#N canvas 256 137 926 686 string-functions 0;
#X obj 342 90 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 49 114 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 342 121 expr symbol(4.52);
#X symbolatom 342 145 10 0 0 0 - - - 0;
#X symbolatom 49 170 13 0 0 0 - - - 0;
#X floatatom 386 446 5 0 0 0 - - - 0;
#X symbolatom 48 443 15 0 0 0 - - - 0;
#X floatatom 638 483 4 0 0 0 - - - 0;
#X symbolatom 379 617 10 0 0 0 - - - 0;
#X obj 379 587 expr strpbrk("hello" \, "lx");
#X floatatom 66 632 5 0 0 0 - - - 0;
#X symbolatom 172 482 20 0 0 0 - - - 0;
#X obj 200 114 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X symbolatom 200 170 10 0 0 0 - - - 0;
#X obj 200 142 expr "\$0-x";
#X text 375 83 turn a float into a symbol, f 13;
#X text 69 67 A string in quotes is output as a symbol., f 21;
#X text 85 217 turn upper case to lower case;
#X obj 48 349 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 379 548 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X text 74 349 concatenate strings;
#X obj 516 96 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X symbolatom 516 146 10 0 0 0 - - - 0;
#X obj 516 121 expr sym(\$0);
#X text 545 98 abbreviation;
#X symbolatom 638 372 10 0 0 0 - - - 0;
#X text 769 325 functions to compare strings, f 15;
#X floatatom 502 444 5 0 0 0 - - - 0;
#X text 179 538 Get span until character in string, f 19;
#X msg 66 531 symbol hello;
#X msg 84 558 symbol bang;
#X text 404 538 return string from found character, f 18;
#X floatatom 231 632 5 0 0 0 - - - 0;
#X obj 66 586 expr strcspn($s1 \, "lg") \; strspn($s1 \, "heban");
#X text 171 14 String Functions: for more info see the HTML reference (or C language manuals), f 79;
#X obj 49 142 expr "hello world";
#X msg 638 316 symbol hello;
#X msg 652 342 symbol HEWORLD;
#X floatatom 689 483 4 0 0 0 - - - 0;
#X floatatom 741 483 4 0 0 0 - - - 0;
#X floatatom 793 483 4 0 0 0 - - - 0;
#X floatatom 845 483 4 0 0 0 - - - 0;
#X obj 638 397 expr strcmp($s1 \, "hello") \; strcmp($s1 \, "HELLO") \; strcasecmp($s1 \, "HELLO") \; strncmp($s1 \, "heWorld" \, 2) \; strncasecmp($s1 \, "HEWORLD" \, 2);
#X symbolatom 223 446 15 0 0 0 - - - 0;
#X obj 386 404 expr strlen($s2) \; strlen("hello");
#X symbolatom 386 377 10 0 0 0 - - - 0;
#X obj 63 247 expr tolower("HELLO") \; tonlower("HELLO" \, 2);
#X obj 63 218 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 344 218 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 344 247 expr toupper("hello") \; tonupper("hello" \, 2);
#X text 366 217 turn lower case to upper case;
#X text 385 353 string length;
#X text 463 376 (type);
#N canvas 732 357 561 376 example 0;
#X floatatom 86 314 5 0 0 0 - - - 0;
#X msg 342 198 symbol expr1_;
#X msg 359 225 symbol expr2_;
#X obj 86 227 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X text 111 226 checking for null symbol input;
#X text 270 153 First bang the [expr] \, then click one of the below \, then bang [expr] again, f 34;
#X obj 318 41 array define expr0_\$0 100;
#X obj 318 64 array define expr1_\$0 50;
#X obj 318 86 array define expr2_\$0 200;
#X msg 369 262 symbol;
#X text 422 262 null symbol;
#X obj 86 261 expr size(strcat(if(!strcmp($s2 \, "") \, "expr0_" \, $s2) \, sym(\$0))), f 37;
#X text 274 17 define arrays of different sizes;
#X text 56 49 Get the size of an array by setting the name with a message and concatenating with the "\$0" symbol. If no symbol is given \, defaults to "expr0_\$0"., f 27;
#X connect 1 0 11 1;
#X connect 2 0 11 1;
#X connect 3 0 11 0;
#X connect 9 0 11 1;
#X connect 11 0 0 0;
#X restore 722 608 pd example;
#X symbolatom 63 292 15 0 0 0 - - - 0;
#X symbolatom 214 292 15 0 0 0 - - - 0;
#X symbolatom 344 292 15 0 0 0 - - - 0;
#X symbolatom 495 292 15 0 0 0 - - - 0;
#X text 683 562 Here's a bit more complicated example, f 20;
#X text 682 98 symbol() takes up to 3 arguments \, see details below, f 21;
#N canvas 348 155 1122 577 symbol() 0;
#X symbolatom 55 232 8 0 0 0 - - - 0;
#X symbolatom 350 434 10 0 0 0 - - - 0;
#X text 108 168 symboln(flt \, decimal length);
#X symbolatom 688 245 13 0 0 0 - - - 0;
#X symbolatom 162 434 10 0 0 0 - - - 0;
#X obj 54 197 expr symbol(4.52 \, $i1);
#X msg 45 62 5;
#X msg 55 87 3;
#X msg 64 112 1;
#X msg 72 137 0;
#X floatatom 55 172 3 0 0 0 - - - 0;
#X msg 347 158 4.52;
#X symbolatom 347 215 5 0 0 0 - - - 0;
#X obj 347 186 makefilename %.0f;
#X msg 485 158 4.52;
#X symbolatom 485 215 6 0 0 0 - - - 0;
#X obj 485 186 makefilename %.3f;
#X text 122 62 No arguments will give you a null symbol \, a single argument is useful to turn a float into a symbol as seen in the parent example. For floats \, a second argument sets the decimal length. This is like setting 'n' in the %.nf syntax of sprintf()., f 66;
#X text 396 140 see also:;
#X text 126 287 For ints and symbols \, 2 arguments is like setting 'n' in %.nd and %.ns respectively., f 51;
#X obj 162 399 expr symbol($i1 \, 3);
#X floatatom 140 353 5 0 0 0 - - - 0;
#X symbolatom 330 513 6 0 0 0 - - - 0;
#X obj 330 478 makefilename %.4s;
#X msg 330 353 symbol hello;
#X obj 350 399 expr symbol($s1 \, 4);
#X symbolatom 140 513 10 0 0 0 - - - 0;
#X obj 140 478 makefilename %.3d;
#X text 647 59 3 arguments produces a symbol from string/symbol \, int \, float \, according to the %m.ns \, %m.nd \, %m.nf syntax in sprintf();
#X obj 670 278 makefilename %5.2f;
#X symbolatom 670 313 14 0 0 0 - - - 0;
#X symbolatom 682 440 10 0 0 0 - - - 0;
#X symbolatom 664 508 10 0 0 0 - - - 0;
#X msg 664 368 symbol hello;
#X obj 682 405 expr symbol($s1 \, 3 \, 5);
#X obj 664 473 makefilename %5.3s;
#X floatatom 897 190 0 0 0 0 - - - 0;
#X symbolatom 917 255 12 0 0 0 - - - 0;
#X msg 897 133 1;
#X msg 859 133 10;
#X symbolatom 897 341 10 0 0 0 - - - 0;
#X obj 917 223 makefilename %5.3d;
#X obj 897 306 expr symbol($i1 \, 3 \, 5);
#X msg 670 137 4.52;
#X floatatom 670 173 7 0 0 0 - - - 0;
#X msg 720 138 1e+07;
#X obj 688 210 expr symbol($f1 \, 2 \, 5);
#X connect 5 0 0 0;
#X connect 6 0 10 0;
#X connect 7 0 10 0;
#X connect 8 0 10 0;
#X connect 9 0 10 0;
#X connect 10 0 5 0;
#X connect 11 0 13 0;
#X connect 13 0 12 0;
#X connect 14 0 16 0;
#X connect 16 0 15 0;
#X connect 20 0 4 0;
#X connect 21 0 20 0;
#X connect 21 0 27 0;
#X connect 23 0 22 0;
#X connect 24 0 23 0;
#X connect 24 0 25 0;
#X connect 25 0 1 0;
#X connect 27 0 26 0;
#X connect 29 0 30 0;
#X connect 33 0 34 0;
#X connect 33 0 35 0;
#X connect 34 0 31 0;
#X connect 35 0 32 0;
#X connect 36 0 41 0;
#X connect 36 0 42 0;
#X connect 38 0 36 0;
#X connect 39 0 36 0;
#X connect 41 0 37 0;
#X connect 42 0 40 0;
#X connect 43 0 44 0;
#X connect 44 0 29 0;
#X connect 44 0 46 0;
#X connect 45 0 44 0;
#X connect 46 0 3 0;
#X restore 719 157 pd symbol();
#X obj 48 378 expr strcat("hello " \, "world") \; strcat("hello " \, "world " \, "again") \; strncat("hello " \, "world" \, 2);
#X text 249 37 Note that functions that output symbols only work in [expr];
#X connect 0 0 2 0;
#X connect 1 0 35 0;
#X connect 2 0 3 0;
#X connect 9 0 8 0;
#X connect 12 0 14 0;
#X connect 14 0 13 0;
#X connect 18 0 61 0;
#X connect 19 0 9 0;
#X connect 21 0 23 0;
#X connect 23 0 22 0;
#X connect 25 0 42 0;
#X connect 29 0 33 0;
#X connect 30 0 33 0;
#X connect 33 0 10 0;
#X connect 33 1 32 0;
#X connect 35 0 4 0;
#X connect 36 0 25 0;
#X connect 37 0 25 0;
#X connect 42 0 7 0;
#X connect 42 1 38 0;
#X connect 42 2 39 0;
#X connect 42 3 40 0;
#X connect 42 4 41 0;
#X connect 44 0 5 0;
#X connect 44 1 27 0;
#X connect 45 0 44 0;
#X connect 46 0 54 0;
#X connect 46 1 55 0;
#X connect 47 0 46 0;
#X connect 48 0 49 0;
#X connect 49 0 56 0;
#X connect 49 1 57 0;
#X connect 61 0 6 0;
#X connect 61 1 11 0;
#X connect 61 2 43 0;
#X restore 130 553 pd string-functions;
#N canvas 202 125 850 540 Other-numeric-functions 0;
#X floatatom 54 26 5 0 0 0 - - - 0;
#X floatatom 54 99 5 0 0 0 - - - 0;
#X text 163 54 convert to int;
#X floatatom 49 272 5 0 0 0 - - - 0;
#X floatatom 49 362 5 0 0 0 - - - 0;
#X text 102 142 convert to float;
#X floatatom 50 217 5 0 0 0 - - - 0;
#X floatatom 194 215 5 0 0 0 - - - 0;
#X floatatom 50 143 5 0 0 0 - - - 0;
#X floatatom 342 32 5 0 0 0 - - - 0;
#X floatatom 342 108 5 0 0 0 - - - 0;
#X floatatom 458 105 5 0 0 0 - - - 0;
#X obj 342 60 expr max($f1 \, 0) \; min($f1 \, 0);
#X text 394 30 maximum / minimum;
#X obj 321 172 expr copysign($f1 \, $f2);
#X floatatom 479 149 5 0 0 0 - - - 0;
#X floatatom 321 147 5 0 0 0 - - - 0;
#X floatatom 321 201 5 0 0 0 - - - 0;
#X text 367 200 copy sign of a number;
#X obj 50 170 expr float($i1) / 10 \; float(5) / 10 \;;
#X floatatom 593 164 5 0 0 0 - - - 0;
#X floatatom 702 163 5 0 0 0 - - - 0;
#X obj 593 119 expr isinf($f1) \; finite($f1);
#X text 721 117 "is infinite" and "is finite", f 15;
#X floatatom 593 87 5 0 0 0 - - - 0;
#X msg 633 29 2;
#X obj 593 54 pow 1e+10;
#X msg 593 27 1;
#X floatatom 601 347 5 0 0 0 - - - 0;
#X floatatom 601 285 5 0 0 0 - - - 0;
#X obj 601 315 expr isnan($f1);
#X text 722 295 "is Nan" (not a number), f 8;
#X floatatom 341 242 5 0 0 0 - - - 0;
#X floatatom 341 311 5 0 0 0 - - - 0;
#X obj 54 54 expr int($f1) \; trunc($f1);
#X floatatom 149 99 5 0 0 0 - - - 0;
#X text 163 69 truncate a float;
#X floatatom 100 362 5 0 0 0 - - - 0;
#X floatatom 151 362 5 0 0 0 - - - 0;
#X obj 49 303 expr rint($f1) \; round($f1) \; nearbyint($f1);
#X floatatom 322 415 5 0 0 0 - - - 0;
#X floatatom 322 495 5 0 0 0 - - - 0;
#X floatatom 387 495 5 0 0 0 - - - 0;
#X floatatom 52 421 5 0 0 0 - - - 0;
#X floatatom 52 494 5 0 0 0 - - - 0;
#X floatatom 154 494 5 0 0 0 - - - 0;
#X text 101 420 ceil / floor;
#X obj 52 449 expr ceil($f1) \; floor($f1);
#X obj 341 268 expr imodf($f1) \; modf($f1);
#X text 325 332 get signed integer, f 10;
#X text 435 334 get signed fractional, f 11;
#X floatatom 450 311 5 0 0 0 - - - 0;
#X floatatom 632 400 5 0 0 0 - - - 0;
#X obj 632 437 expr abs($f1);
#X floatatom 632 474 5 0 0 0 - - - 0;
#X text 680 399 absolute value;
#X obj 601 215 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X msg 322 384 7;
#X obj 601 251 expr log(-1);
#X text 100 264 round floats to integers, f 12;
#X floatatom 452 495 5 0 0 0 - - - 0;
#X msg 289 384 -7;
#X text 458 440 (integer);
#X text 458 454 (float);
#X obj 322 440 expr $f1 % 4 \; fmod($f1 \, 4.1) \; remainder($f1 \, 4.1);
#X text 371 412 remainder functions;
#X text 105 27 convert to integers;
#X connect 0 0 34 0;
#X connect 3 0 39 0;
#X connect 8 0 19 0;
#X connect 9 0 12 0;
#X connect 12 0 10 0;
#X connect 12 1 11 0;
#X connect 14 0 17 0;
#X connect 15 0 14 1;
#X connect 16 0 14 0;
#X connect 19 0 6 0;
#X connect 19 1 7 0;
#X connect 22 0 20 0;
#X connect 22 1 21 0;
#X connect 24 0 22 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 27 0 26 0;
#X connect 29 0 30 0;
#X connect 30 0 28 0;
#X connect 32 0 48 0;
#X connect 34 0 1 0;
#X connect 34 1 35 0;
#X connect 39 0 4 0;
#X connect 39 1 37 0;
#X connect 39 2 38 0;
#X connect 40 0 64 0;
#X connect 43 0 47 0;
#X connect 47 0 44 0;
#X connect 47 1 45 0;
#X connect 48 0 33 0;
#X connect 48 1 51 0;
#X connect 52 0 53 0;
#X connect 53 0 54 0;
#X connect 56 0 58 0;
#X connect 57 0 40 0;
#X connect 58 0 29 0;
#X connect 61 0 40 0;
#X connect 64 0 41 0;
#X connect 64 1 42 0;
#X connect 64 2 60 0;
#X restore 130 437 pd Other-numeric-functions;
#N canvas 697 352 400 291 var-function 0;
#X obj 249 108 loadbang;
#X msg 209 142 5;
#X msg 249 142 3;
#X msg 292 142 2.5;
#X obj 69 194 expr var($s1);
#X floatatom 69 228 5 0 0 0 - - - 0;
#X text 64 34 The 'var' function takes a symbol and interprets it as a variable name., f 37;
#X obj 209 221 value x;
#X obj 249 194 value y;
#X obj 292 168 value z;
#X msg 69 101 symbol x;
#X msg 82 131 symbol y;
#X msg 92 160 symbol z;
#X connect 0 0 2 0;
#X connect 0 0 3 0;
#X connect 0 0 1 0;
#X connect 1 0 7 0;
#X connect 2 0 8 0;
#X connect 3 0 9 0;
#X connect 4 0 5 0;
#X connect 10 0 4 0;
#X connect 11 0 4 0;
#X connect 12 0 4 0;
#X restore 130 466 pd var-function;
#N canvas 369 170 564 371 Acoustic-conversion-functions 0;
#X obj 70 137 expr mtof($f1);
#X obj 70 209 expr ftom($f1);
#X obj 216 137 expr dbtorms($f1);
#X obj 216 209 expr rmstodb($f1);
#X obj 63 314 mtof;
#X obj 119 314 ftom;
#X obj 175 315 dbtorms;
#X obj 251 315 rmstodb;
#X obj 330 315 dbtopow;
#X obj 407 315 powtodb;
#X text 63 289 See also:;
#X obj 377 140 expr dbtopow($f1);
#X obj 377 212 expr powtodb($f1);
#X text 63 67 MTDI x Hertz;
#X text 83 18 Acoustic conversions;
#X text 238 71 dB x RMS;
#X text 396 72 dB x Power;
#X floatatom 70 243 9 0 0 0 - - - 0;
#X floatatom 216 243 9 0 0 0 - - - 0;
#X floatatom 377 246 9 0 0 0 - - - 0;
#X floatatom 70 174 9 0 0 0 - - - 0;
#X floatatom 216 174 9 0 0 0 - - - 0;
#X floatatom 377 177 9 0 0 0 - - - 0;
#X floatatom 70 99 9 0 0 0 - - - 0;
#X floatatom 216 99 9 0 0 0 - - - 0;
#X floatatom 377 102 9 0 0 0 - - - 0;
#X connect 0 0 20 0;
#X connect 1 0 17 0;
#X connect 2 0 21 0;
#X connect 3 0 18 0;
#X connect 11 0 22 0;
#X connect 12 0 19 0;
#X connect 20 0 1 0;
#X connect 21 0 3 0;
#X connect 22 0 12 0;
#X connect 23 0 0 0;
#X connect 24 0 2 0;
#X connect 25 0 11 0;
#X restore 130 408 pd Acoustic-conversion-functions;
#X text 41 19 Here are all the operators and functions available for [expr] \, [expr~] and [fexpr~]. The functions that output a symbol string are only possible with [expr]. All other functions work for the three objects \, even though the given examples are only presented with [expr]., f 53;
#X restore 505 547 pd All_functions \; and operators;
#N canvas 327 86 952 778 [expr] 0;
#X obj 206 123 expr 1;
#X floatatom 206 153 4 0 0 0 - - - 0;
#X floatatom 297 151 4 0 0 0 - - - 0;
#X floatatom 64 406 0 0 0 0 - - - 12;
#X floatatom 557 64 6 0 0 0 - - - 0;
#X floatatom 557 144 8 0 0 0 - - - 0;
#X floatatom 573 353 0 0 0 0 - - - 0;
#X obj 573 325 expr 8 / 3;
#X floatatom 707 592 0 0 0 0 - - - 0;
#X floatatom 768 592 0 0 0 0 - - - 0;
#X obj 557 96 expr cos(2 * 3.14159 * $f1 / 360) \; sin(2 * 3.14159 * $f1 / 360);
#X floatatom 308 450 5 0 0 0 - - - 0;
#X floatatom 308 558 5 0 0 0 - - - 0;
#X floatatom 352 557 5 0 0 0 - - - 0;
#X floatatom 396 557 5 0 0 0 - - - 0;
#X obj 352 597 print expr;
#X obj 64 375 expr ($f1 + 2) * $i2;
#X text 71 111 A bang evaluates the expression, f 17;
#X text 609 63 example of trigonometric functions;
#X floatatom 793 354 0 0 0 0 - - - 0;
#X msg 793 302 8;
#X obj 793 326 expr $f1 / 3;
#X floatatom 679 353 0 0 0 0 - - - 0;
#X msg 679 301 8;
#X obj 679 325 expr $i1 / 3;
#X text 508 219 Integer numbers inside the [expr] object are interpreted as integers \, not floats. Hence \, the result of the division below to the left is also an integer and it's the same if you have an '$i#' variable \, but '$f#' works fine.;
#X obj 707 530 expr float(8) / 3 \; (8.) / 3 \; 8./3;
#X floatatom 830 592 0 0 0 0 - - - 0;
#X obj 297 123 expr 2 + 3.2;
#X text 496 189 NOTE About integers and integer variable types:;
#X obj 169 339 t b f;
#X floatatom 64 312 6 0 0 0 - - - 0;
#X floatatom 169 312 6 0 0 0 - - - 0;
#X text 28 202 '$f1' is a float from the 1st inlet \, '$i2' is an integer from the second inlet (so float input values are truncated to integers).;
#X obj 308 486 expr $f1 + 1 \; $f1 - 1 \; $f1 * 2 + 1;
#X text 234 364 See how '()' is used to force an operation priority for the sum. Otherwise '*' and '/' have priority., f 33;
#X text 231 306 Note that a bang also evaluates the expression with the previously set values., f 34;
#X text 57 470 A semicolon can be used to create and separate different expressions (up to 100). If so \, an outlet is created for each expression and they're evaluated from right to left (or bottom to up) order:, f 30;
#X text 507 399 Pd turns "8.0" into "8" and [expr] will see it as an integer. One way to deal with this is with the "float" function to convert an integer to a float. A possible workaround is to have just a decimal point and the number inside parenthesis. Pd sees this as a symbol and doesn't remove the dot and [expr] will see it as a float. Other hacks like that are possible \, see below:, f 61;
#X obj 206 95 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 297 95 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 573 298 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 707 503 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 560 34 hsl 162 17 0 360 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X floatatom 792 144 8 0 0 0 - - - 0;
#X msg 37 268 3 4;
#X text 72 262 a list input spreads values into inlets (as is common in Pd)., f 33;
#X text 30 31 Here are some basic examples of the [expr] object. This object only takes the variables: "$f#" \, "$i#" and "$s#"., f 63;
#X text 534 546 '8.' becomes a float -->;
#X text 534 560 also becomes a float -->;
#X symbolatom 143 704 10 0 0 0 - - - 0;
#X obj 143 655 expr "hello" \; $s1;
#X symbolatom 231 703 10 0 0 0 - - - 0;
#X msg 143 618 symbol world;
#X text 335 648 Symbol strings are also supported in [expr] \, which can also output symbols. You can define a symbol string if it's inside quotes., f 75;
#X text 259 653 <---------;
#X text 335 682 If not inside quotes \, symbols will be either treated as variable names (defined in [value] objects) or as array names (if you use index values inside brackets \, more info on both cases in [pd [value] and [pd Arrays] in the parent patch). There are also functions for manipulating strings (see [pd All_functions] in the parent as well)., f 75;
#X connect 0 0 1 0;
#X connect 4 0 10 0;
#X connect 7 0 6 0;
#X connect 10 0 5 0;
#X connect 10 1 44 0;
#X connect 11 0 34 0;
#X connect 12 0 15 0;
#X connect 13 0 15 0;
#X connect 14 0 15 0;
#X connect 16 0 3 0;
#X connect 20 0 21 0;
#X connect 21 0 19 0;
#X connect 23 0 24 0;
#X connect 24 0 22 0;
#X connect 26 0 8 0;
#X connect 26 1 9 0;
#X connect 26 2 27 0;
#X connect 28 0 2 0;
#X connect 30 0 16 0;
#X connect 30 1 16 1;
#X connect 31 0 16 0;
#X connect 32 0 30 0;
#X connect 34 0 12 0;
#X connect 34 1 13 0;
#X connect 34 2 14 0;
#X connect 39 0 0 0;
#X connect 40 0 28 0;
#X connect 41 0 7 0;
#X connect 42 0 26 0;
#X connect 43 0 4 0;
#X connect 45 0 16 0;
#X connect 51 0 50 0;
#X connect 51 1 52 0;
#X connect 53 0 51 0;
#X restore 226 500 pd [expr] Examples;
#N canvas 354 38 837 696 [expr~] 0;
#X floatatom 50 374 5 0 0 0 - - - 0;
#X obj 50 481 dac~;
#X text 95 374 frequency;
#X floatatom 743 257 7 0 10 0 - - - 0;
#X obj 536 328 tabsend~ a1;
#X obj 546 458 tabsend~ a2;
#X obj 711 454 tabsend~ a3;
#X obj 50 401 osc~ 440;
#X floatatom 250 360 8 0 0 0 - - - 0;
#X text 314 360 amplitude;
#X obj 250 412 line~;
#X obj 50 442 expr~ $v1 * pow($v2 / 127 \, 4);
#X obj 546 408 expr~ $v1 * $v2 \; if ($v2 > 0 \, 0 \, $v1*$v2);
#X obj 546 375 osc~ 440;
#X obj 536 251 osc~ 440;
#X obj 536 289 expr~ max(min($v1 \, $f2) \, -$f2);
#X text 518 186 Move the slider to change the limiter threshold (from 0-1)., f 29;
#X obj 142 323 print~;
#X floatatom 244 233 5 0 0 0 - - - 0;
#X floatatom 142 208 6 0 0 0 - - - 0;
#X obj 142 235 sig~ 1;
#X obj 711 375 osc~ 550;
#X text 516 162 A simple limiter/clip example:;
#X text 47 242 Examples:;
#X text 468 21 NOTE: The vector/block size can be set with the [block~] or [switch~] objects \, and is 64 samples by default., f 49;
#X msg 250 386 \$1 20;
#X obj 561 79 block~ 64;
#X text 486 79 see also:;
#X obj 142 263 expr~ $v1 + $v2;
#X msg 290 55 \; pd dsp \$1;
#X text 359 404 a semicolon also creates more expressions and outlets (up to 100), f 24;
#X text 58 33 make sure to turn on the audio for the [expr~] examples ----->, f 31;
#X obj 160 294 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 253 331 hsl 162 19 0 1 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 743 72 vsl 19 162 0 1 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 290 20 set-dsp-tgl;
#X text 321 24 DSP on/off;
#X obj 541 529 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#X obj 320 529 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#X obj 104 528 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a1 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 103 527 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a2 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 319 528 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a3 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 540 528 graph;
#X text 16 105 Besides '$f#' \, '$i#' and '$s#' \, [expr~] takes '$v#' variables. Note that the first inlet of [expr~] needs to be of type '$v1'. The reasoning is that you must at least one signal input to justify using [expr~] \, so let it be the first one. You can still send floats to this left inlet as floats sent to audio inlets are promoted to signals., f 64;
#X connect 0 0 7 0;
#X connect 3 0 15 1;
#X connect 7 0 11 0;
#X connect 8 0 25 0;
#X connect 10 0 11 1;
#X connect 11 0 1 0;
#X connect 11 0 1 1;
#X connect 12 0 5 0;
#X connect 12 1 6 0;
#X connect 13 0 12 0;
#X connect 14 0 15 0;
#X connect 15 0 4 0;
#X connect 18 0 28 1;
#X connect 19 0 20 0;
#X connect 20 0 28 0;
#X connect 21 0 12 1;
#X connect 25 0 10 0;
#X connect 28 0 17 0;
#X connect 32 0 17 0;
#X connect 33 0 8 0;
#X connect 34 0 3 0;
#X connect 35 0 29 0;
#X restore 219 528 pd [expr~] Examples;
#N canvas 222 38 1094 690 [fexpr~] 0;
#X text 90 365 - $x1: same as $x1[0] \, $x2: same as $x2[0] (and so on)., f 60;
#X text 90 347 - $x: same as $x1[0]., f 60;
#X text 90 383 - $y: same as $y1[-1]., f 60;
#X text 90 401 - $y1: same as $y1[-1] \, $y2: same as $y2[-1] (and so on)., f 60;
#X msg 670 165 start;
#X msg 618 165 stop;
#X obj 618 135 loadbang;
#X msg 739 162 set 4000;
#X obj 726 128 sig~ 0.001;
#X obj 726 230 fexpr~ $x1[0] + $y1[-1];
#X msg 753 196 clear y1;
#X text 820 196 clears output buffer;
#X obj 726 268 snapshot~;
#X obj 590 220 metro 100;
#X obj 590 195 tgl 19 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000 0 1;
#X floatatom 726 293 8 0 0 0 - - - 0;
#X text 806 127 increment value;
#X text 804 161 set last output value ($y1[-1]);
#X text 83 605 - clear: clears all the previous input and output buffers, f 60;
#X text 83 569 - clear x#: clears the previous values of the #th input, f 60;
#X text 83 587 - clear y#: clears the previous values of the #th output, f 60;
#X text 83 490 - set y# <list>: sets the as many supplied values of the #th output (e.g. "set y3 1 2" sets $y3[-1] = 1 and $y3[-2] = 2).;
#X floatatom 816 517 5 0 0 0 - - - 0;
#X msg 617 483 start;
#X msg 571 483 stop;
#X obj 571 450 loadbang;
#X msg 777 479 0;
#X obj 672 553 fexpr~ $x1 + $x1[$f2];
#X msg 672 425 1102.5;
#X floatatom 672 483 7 0 0 0 - - - 0;
#X text 556 342 Simple FIR filter:, f 58;
#X msg 856 479 -20;
#X msg 816 479 -10;
#X text 754 433 change values to filter the frequencies, f 23;
#X text 83 523 - set <list>: sets the first past values of each output (e.g. "set 0.1 2.2 0.4" sets y1[-1] = 0.1 \, y2[-1] = 2.2 \, and y3[-1] = 0.4).;
#X text 83 458 - set x# <list>: sets as many supplied values of the #th input (e.g. "set x2 1 2" sets $x2[0] = 1 and $x2[-1] = 2)., f 60;
#X text 561 85 Simple accumulator example:;
#X text 49 433 [fexpr~] responds to the following methods:, f 63;
#X text 933 579 more examples:;
#X text 612 364 -10 offset filters audio at frequency of 2205 Hz -20 offset filters audio at frequency of 1102.5 Hz, f 50;
#X msg 689 452 2205;
#X obj 672 514 osc~ 2205;
#X text 24 26 NOTE: - [fexpr~] operates on sample level data for things like filter design and can be very cpu intensive!, f 69;
#X text 52 325 There are shorthands as follows:;
#X text 83 623 - stop: stops the computation of [fexpr~], f 60;
#X text 83 641 - start: starts the computation of [fexpr~], f 60;
#X text 558 18 As noted \, [fexpr~] can be CPU expensive! By default \, [fexpr~] is on when it is loaded \, but you can save CPU and control when it is on or off with the 'start' and 'stop' messages. Below \, you need to click 'start' to get it running., f 73;
#X msg 917 271 \; pd dsp \$1;
#X obj 672 600 output~;
#X obj 924 519 declare -stdpath ./;
#N canvas 695 185 533 408 fractional-sample-index 0;
#X msg 130 190 start;
#X msg 78 189 stop;
#X obj 78 158 loadbang;
#X floatatom 305 176 9 -10 0 0 - - - 0;
#X obj 305 233 line~;
#X msg 305 203 \$1 100;
#X obj 161 222 osc~ 2205;
#X text 209 128 fractional sample index offset, f 17;
#X obj 161 264 fexpr~ $x1 + $x1[$x2];
#X text 25 16 When fractional index offset is used for either input or output samples (with '$f#' or '$x#' variables) \, [fexpr~] determines the value by linear interpolation., f 63;
#X text 25 69 In the following example \, you can continuously change the sample input index from 0 to -10 (the point that filters the frequency of 2205 Hz)., f 63;
#X obj 161 314 output~;
#X obj 308 150 hsl 162 19 0 -10 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 4 0 8 1;
#X connect 5 0 4 0;
#X connect 6 0 8 0;
#X connect 8 0 11 0;
#X connect 12 0 3 0;
#X restore 854 605 pd fractional-sample-index;
#N canvas 286 64 900 597 difference-equations(Lorenz) 0;
#X obj 194 193 v pr;
#X obj 341 193 v r;
#X obj 249 195 v b;
#X floatatom 194 164 5 0 0 0 - - - 0;
#X floatatom 341 166 5 0 0 0 - - - 0;
#X msg 194 139 10;
#X msg 172 251 set 1.2 2.3 4.4;
#X floatatom 249 165 7 0 0 0 - - - 0;
#X floatatom 399 166 5 0 0 0 - - - 0;
#X obj 399 195 v dt;
#X msg 341 137 18;
#X msg 399 127 0.01;
#X obj 172 65 bng 25 250 50 0 empty empty empty 20 8 0 8 #dfdfdf #000000 #000000;
#X obj 449 136 line;
#X msg 449 110 0.01 \, 0.04 5000;
#X obj 101 193 loadbang;
#N canvas 0 50 450 300 (subpatch) 0;
#X array X 64 float 0;
#X coords 0 20 63 -20 200 140 1 0 0;
#X restore 178 423 graph;
#X obj 249 136 expr 8./3;
#X text 587 289 $y1 -> $y1[-1] $y2 -> $y2[-1] $y3 -> $y3[-1], f 15;
#X text 145 547 -20;
#X text 152 416 20;
#X text 381 547 -20;
#X text 388 416 20;
#X text 635 547 0;
#X text 630 416 40;
#X text 624 24 Lorenz Equations written with 3 state variables X \, Y \, and Z:, f 30;
#X text 670 67 dX/dt = pr * (Y - X);
#X text 670 87 dY/dt = X(r - Z) - Y;
#X text 670 107 dZ/dt = X*Y - bZ, f 20;
#X obj 172 285 fexpr~ $y1 + pr*($y2 - $y1) * dt \; $y2 + ($y1*(r - $y3) - $y2) * dt \; $y3 + ($y1*$y2 - b*$y3) * dt;
#X obj 172 359 tabsend~ X;
#X obj 286 359 tabsend~ Y;
#X obj 400 360 tabsend~ Z;
#X msg 101 218 stop;
#X text 475 182 hear a click and audio stops \, the system went unstable and you need to bang on the top again to reload the default values., f 46;
#X msg 43 220 start;
#X obj 36 444 output~;
#X text 241 19 This is an example of how [fexpr~] can be used to solve differential equations such as the lorenz equations. Semicolons create new outlets as usual (up to 100). Here we have 3 expressions \, so we now have '$y2' and '$y3' variables., f 49;
#X text 412 301 <00 Note the shorthands:;
#X text 294 250 <-- sets initial values of $y1[-1] \, $y2[-1] \, and $y3[-1];
#X text 446 165 <-- experiment with these parameter values. If you;
#X text 98 52 bang to start -->, f 9;
#X obj 179 424 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#X obj 419 422 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#X obj 656 421 cnv 19 198 138 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Y 64 float 0;
#X coords 0 20 63 -20 200 140 2 0 0;
#X restore 418 421 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Z 64 float 0;
#X coords 0 40 63 0 200 140 2 0 0;
#X restore 655 420 graph;
#X connect 3 0 0 0;
#X connect 4 0 1 0;
#X connect 5 0 3 0;
#X connect 6 0 29 0;
#X connect 7 0 2 0;
#X connect 8 0 9 0;
#X connect 10 0 4 0;
#X connect 11 0 8 0;
#X connect 12 0 5 0;
#X connect 12 0 10 0;
#X connect 12 0 11 0;
#X connect 12 0 6 0;
#X connect 12 0 35 0;
#X connect 12 0 17 0;
#X connect 13 0 8 0;
#X connect 14 0 13 0;
#X connect 15 0 33 0;
#X connect 17 0 7 0;
#X connect 29 0 30 0;
#X connect 29 0 36 0;
#X connect 29 1 31 0;
#X connect 29 2 32 0;
#X connect 33 0 29 0;
#X connect 35 0 29 0;
#X restore 819 633 pd difference-equations(Lorenz);
#X obj 340 155 fexpr~ $x1[0] + $y1[-1];
#X text 62 192 'n' index for '$x#' is from 0 to minus "vector size - 1"., f 58;
#X text 23 63 Besides '$f#' \, '$i#' and '$s#' \, [fexpr~] takes '$x#' and '$y#' variables (and no '$v#' variables from [expr~]). Note that the first inlet of [fexpr~] needs to be of type '$x1' (cannot be '$f1' \, '$i1' or '$s1'). You can still send floats to this left inlet as floats sent to audio inlets are promoted to signals. The '$x#' and '$y#' types are input and output samples defined by 'n':, f 71;
#X text 23 243 The vector (or 'block') size is defined by the [block~] or [switch~] objects. The default is 64 so it's from 0 to -63 for '$x#' and -1 to -63 for $y#. As such \, $x#[0] specifies the current sample input \, and $y#[-1] the last sample output., f 72;
#X obj 917 234 set-dsp-tgl;
#X text 948 238 DSP on/off;
#X text 62 210 'n' index for '$y#' is from -1 to minus "vector size - 1".;
#X connect 4 0 9 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 6 0 14 0;
#X connect 7 0 9 0;
#X connect 8 0 9 0;
#X connect 9 0 12 0;
#X connect 10 0 9 0;
#X connect 12 0 15 0;
#X connect 13 0 12 0;
#X connect 14 0 13 0;
#X connect 22 0 27 1;
#X connect 23 0 27 0;
#X connect 24 0 27 0;
#X connect 25 0 24 0;
#X connect 26 0 22 0;
#X connect 27 0 48 0;
#X connect 28 0 29 0;
#X connect 29 0 41 0;
#X connect 31 0 22 0;
#X connect 32 0 22 0;
#X connect 40 0 29 0;
#X connect 41 0 27 0;
#X connect 56 0 47 0;
#X restore 212 555 pd [fexpr~] Examples;
#X obj 407 608 >;
#X text 102 522 (click on the subpatches to open them), f 13;
#X obj 282 667 random;
#X obj 105 258 expr $f1 + $s3[$i2];
#X symbolatom 235 232 7 0 0 0 - - - 0;
#X floatatom 170 231 3 0 0 0 - - - 0;
#X floatatom 105 232 4 0 0 0 - - - 0;
#X obj 278 329 sig~ 1;
#X obj 74 448 fexpr~ $x1[0] + $y1[-1];
#X text 62 297 [expr~] has an exclusive input variable defined as '$v#' - which stands for an audio signal 'vector' (or block)., f 85;
#X text 49 394 [fexpr~] has exclusive variable types defined as: '$x#[n]' (an input audio sample from inlet # indexed by 'n') and '$y#[n]' (an output audio sample from outlet # indexed by 'n')., f 91;
#X text 307 224 First inlet is a float input that adds to an array value whose index is defined by an integer input from the second inlet and the third inlet takes a symbol for the array name., f 50;
#X obj 338 667 array;
#X obj 278 355 expr~ $v1 + $f2;
#X floatatom 401 355 5 0 0 0 - - - 0;
#X obj 386 667 cos~;
#X obj 70 33 expr;
#X obj 63 58 expr~;
#X obj 57 96 fexpr~;
#X text 107 96 - evaluation of audio signal expressions;
#X text 107 58 - evaluation of audio signal expressions;
#X text 107 33 - evaluation of control data expressions;
#X text 121 76 on a vector by vector basis, f 38;
#X text 121 113 on a sample by sample basis, f 38;
#X obj 7 137 cnv 1 730 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X obj 451 57 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#N canvas 798 148 456 264 reference 0;
#X obj 101 59 inlet;
#X obj 101 190 pdcontrol;
#X obj 101 130 pdcontrol;
#X msg 101 105 dir;
#X text 205 94 this window opens the html reference link via the [pdcontrol] object., f 25;
#X msg 101 159 browse \$1/../8.topics/expr.htm;
#X connect 0 0 3 0;
#X connect 2 0 5 0;
#X connect 3 0 2 0;
#X connect 5 0 1 0;
#X restore 451 91 pd reference;
#X obj 8 592 cnv 1 730 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 655 90 <= click;
#N canvas 649 125 573 524 reference 0;
#X obj 9 43 cnv 5 550 5 empty empty INLETS: 8 18 0 13 #202020 #000000 0;
#X obj 9 258 cnv 2 550 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000 0;
#X obj 9 367 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 8 495 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 8 178 cnv 1 550 1 empty empty 'n': 8 12 0 13 #7c7c7c #000000 0;
#X obj 22 10 expr;
#X text 82 52 (arguments set 'n' number of inlets and type);
#X text 77 201 symbol - if inlet type is '$s#' or '$i#'., f 44;
#X obj 8 291 cnv 1 550 1 empty empty 'n': 8 12 0 13 #7c7c7c #000000 0;
#X text 83 263 (number of expressions define 'n' numbers of outlets);
#X text 12 394 1) list -;
#X obj 62 10 expr~;
#X obj 110 10 fexpr~;
#X text 100 298 float - (for [expr] only) expression result., f 58;
#X text 93 336 signal - (for [expr~] and [fexpr~] only) expression result.;
#X text 164 9 - expression evaluation family of objects.;
#X text 77 219 signal -;
#X text 140 219 if inlet type is '$v#' ([expr~]) or '$x#' ([fexpr~]) \, leftmost inlet is always signal in [expr~]/[fexpr~].;
#X obj 8 78 cnv 1 550 1 empty empty leftmost: 8 12 0 13 #7c7c7c #000000 0;
#X text 32 139 clear <symbol> -;
#X text 102 83 bang - in [expr]: evaluate expression., f 64;
#X text 60 101 set <list> - in [fexpr~]: set values for previous input/output values., f 70;
#X text 60 119 stop/start - in [fexpr~]: stop/start computation., f 70;
#X text 151 139 in [fexpr~]: clear input/output memory \, optional symbol specifies a specific input (such as x1) or output (y1)., f 57;
#X text 84 183 float - if inlet type is '$f#' or '$i#' ('#' is inlet number)., f 62;
#X text 93 316 symbol - (for [expr] only) expression result., f 59;
#X text 82 394 expression including operators \, functions \, inlet types \, float and symbols. See html reference and examples for all operators and functions. Semicolons create more expressions (and outlets). Inlet type has the format '$t#' - where 't' is type (f \, i \, s \, v and x) and # is the inlet number \, [fexpr~]'s 'x' and 'y' types also have a sample number inside brackets (default: output zeros)., f 66;
#X restore 561 91 pd reference;
#X text 338 328 <-- 1st inlet is an audio signal vector/block;
#X text 256 440 'n' index for '$x#' is from 0 to minus "vector size - 1".;
#X text 474 57 <-- Open HTML reference;
#X obj 85 608 abs;
#X obj 116 608 abs~;
#X obj 153 608 +;
#X obj 184 608 +~;
#X obj 85 636 mtof;
#X obj 123 636 mtof~;
#X text 166 635 - acoustic conversions;
#X obj 407 636 sin;
#X text 438 607 - other binary operators (control only), f 40;
#X text 438 635 - trigonometric functions (control only);
#X text 26 3 Expression evaluation family of objects By Shahrokh Yadegari - Version 0.58, f 75;
#X obj 85 667 makefilename;
#X text 43 151 These objects have several built in operators and functions and the syntax is quite similar to how expressions are written in C. They receive input variables via the inlets and understand the variable types: '$f#' (floats) \, '$i#' (integers) and '$s#' (symbols) - '#' is the inlet number (up to 100) as below:, f 94;
#X text 503 668 Updated for Pd version 0.55-1;
#N canvas 485 110 870 672 [value] 0;
#X floatatom 600 226 5 0 0 0 - - - 0;
#X obj 600 161 until;
#X msg 723 162 0;
#X obj 723 192 v i;
#X obj 600 193 expr i = i + 1;
#X msg 600 96 10;
#X obj 600 253 print;
#X obj 184 84 loadbang;
#X obj 144 197 value a;
#X obj 184 170 value b;
#X obj 227 144 value c;
#X obj 129 350 expr (a + b) / c;
#X floatatom 129 384 5 0 0 0 - - - 0;
#X obj 600 127 trigger float bang;
#X obj 701 312 expr i * 2 \; i = i + 1;
#X floatatom 701 358 5 0 0 0 - - - 0;
#X floatatom 775 359 5 0 0 0 - - - 0;
#X text 71 246 All you have to do is just use the variable name into the expression:, f 27;
#X obj 128 435 expr~ (a + b) / c;
#X obj 128 466 print~;
#X msg 144 118 5;
#X msg 184 118 3;
#X msg 227 118 2.5;
#X obj 129 546 print~;
#X obj 129 515 fexpr~ (a + b) / c;
#X obj 575 529 v last;
#X obj 449 560 fexpr~ last = $x1[-1] \; $x1[0] - last;
#X obj 600 615 print~;
#X obj 449 529 phasor~ 1000;
#X text 37 25 [expr] \, [expr~] and [fexpr~] can access variables set into [value] objects., f 34;
#X text 538 14 It is also possible to assign values to variables inside the expr family of objects with "=" (a.k.a the "store function")., f 38;
#X obj 129 321 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 100 435 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 101 515 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 634 580 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 701 277 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 23 119 loading values into [value] objects ------->, f 16;
#X text 329 315 Expressions are output from right to left order in [expr] \, since they're evaluated from bottom to top. This means you need to update a variable and call it in the above expression \, check it ------------->, f 51;
#X obj 371 211 expr var($s1);
#X msg 371 118 symbol a;
#X floatatom 371 245 5 0 0 0 - - - 0;
#X msg 384 148 symbol b;
#X msg 394 177 symbol c;
#X text 348 37 The 'var' function takes a symbol and interprets it as a variable name., f 19;
#X text 298 419 You can technically assign variable values in [expr~] \, but this doesn't really make sense as it deals with whole signal vectors and not single values. As for [fexpr~] \, this can be useful as it operates on a sample by sample basis \, note however that they're evaluated from top to bottom instead. This means you need to update a variable and call it in the below expression \, check the following example:, f 75;
#X connect 0 0 6 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 4 0 0 0;
#X connect 5 0 13 0;
#X connect 7 0 21 0;
#X connect 7 0 22 0;
#X connect 7 0 20 0;
#X connect 11 0 12 0;
#X connect 13 0 1 0;
#X connect 13 1 2 0;
#X connect 14 0 15 0;
#X connect 14 1 16 0;
#X connect 18 0 19 0;
#X connect 20 0 8 0;
#X connect 21 0 9 0;
#X connect 22 0 10 0;
#X connect 24 0 23 0;
#X connect 26 1 27 0;
#X connect 28 0 26 0;
#X connect 31 0 11 0;
#X connect 32 0 19 0;
#X connect 33 0 23 0;
#X connect 34 0 27 0;
#X connect 35 0 14 0;
#X connect 38 0 40 0;
#X connect 39 0 38 0;
#X connect 41 0 38 0;
#X connect 42 0 38 0;
#X restore 580 489 pd [value] & var();
#X text 213 607 - unary/binary operators;
#X text 256 457 'n' index for '$y#' is from -1 to minus "vector size - 1".;
#X connect 15 0 14 2;
#X connect 16 0 14 1;
#X connect 17 0 14 0;
#X connect 18 0 24 0;
#X connect 25 0 24 1;
#X connect 36 0 37 0;
