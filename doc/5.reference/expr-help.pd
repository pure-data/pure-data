#N canvas 423 23 745 688 12;
#X declare -stdpath ./;
#N canvas 556 54 810 635 Arrays 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array array100 10 float 0;
#X coords 0 10 9 0 220 130 1 0 0;
#X restore 537 143 graph;
#X floatatom 183 354 0 0 9 0 - - - 0;
#X floatatom 183 411 0 0 0 0 - - - 0;
#X obj 183 383 expr $s2[$f1];
#X obj 549 41 loadbang;
#X floatatom 99 102 5 0 9 0 - - - 0;
#X floatatom 99 178 5 0 0 0 - - - 0;
#X text 29 65 For instance:;
#X obj 271 326 loadbang;
#X floatatom 550 433 0 0 100 0 - - - 0;
#X obj 550 314 vsl 20 100 0 10 0 0 empty empty empty 0 -9 0 10 #fcfcfc
#000000 #000000 0 1;
#X text 245 132 input is the index to read from the array, f 21;
#X text 27 23 [expr] \, [expr~] and [fexpr~] can read values from array
(without interpolation). The syntax is arrayname[index].;
#X text 28 271 A symbol inlet - defined as '$s#' (# being the inlet
number) - is used to receive the array names.;
#X text 255 450 [expr] can set values to an array index with "=" (a.k.a.
"store function") as in:, f 41;
#X text 27 214 Note that variables '$f#' are also possible as the array
index \, but it won't make sense since there's no interpolation and
float inputs are just truncated to integers., f 64;
#X text 90 531 Even though you can also use arrays in [expr~] and [fexpr~].
They cannot write values to arrays and the index values cannot be audio
variables (just either '$i3' or '$f#').;
#X msg 549 73 \; array100 0 1 4 2 8 5 6 1 4 2 8;
#X msg 271 355 symbol array100;
#X obj 99 139 expr array100[$i1];
#X obj 550 464 expr array100[1] = $f1;
#X obj 550 532 expr~ $v1 + array100[1];
#X obj 550 559 fexpr~ $x1 + array100[1];
#X connect 1 0 3 0;
#X connect 3 0 2 0;
#X connect 4 0 17 0;
#X connect 5 0 19 0;
#X connect 8 0 18 0;
#X connect 9 0 20 0;
#X connect 10 0 9 0;
#X connect 18 0 3 1;
#X connect 19 0 6 0;
#X restore 475 497 pd Arrays;
#X text 88 499 Basic examples:;
#X text 399 520 Further details:, f 8;
#N canvas 416 139 950 501 Dealing_with_"\$0" 0;
#X obj 624 154 expr $s2[$f1];
#X obj 712 123 symbol \$0-x;
#X floatatom 624 128 5 0 99 0 - - - 0;
#X floatatom 624 182 5 0 0 0 - - - 0;
#X obj 712 100 loadbang;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-x 100 float 1;
#A 0 -0.720016 -0.706683 -0.693349 -0.680016 -0.666682 -0.653348 -0.640015
-0.625014 -0.610014 -0.595014 -0.580013 -0.565013 -0.550013 -0.535012
-0.520012 -0.505012 -0.490011 -0.475011 -0.460011 -0.44501 -0.43001
-0.415009 -0.400009 -0.385009 -0.370008 -0.355008 -0.340008 -0.325007
-0.310007 -0.295007 -0.280006 -0.264006 -0.248006 -0.232005 -0.216005
-0.200005 -0.184004 -0.168004 -0.152003 -0.136003 -0.120003 -0.106669
-0.0933355 -0.0800018 -0.0666682 -0.0533346 -0.0400009 -0.0266673 -0.0133336
-3.10441e-10 0.0133336 0.0266673 0.0400009 0.0533346 0.0666682 0.0800018
0.0933355 0.106669 0.120003 0.133336 0.14667 0.160004 0.173337 0.186671
0.200005 0.213338 0.226672 0.240005 0.253339 0.266673 0.280006 0.29715
0.314293 0.331436 0.348579 0.365723 0.382866 0.400009 0.413343 0.426676
0.44001 0.453344 0.466677 0.480011 0.500011 0.520012 0.540012 0.560013
0.570013 0.580013 0.590014 0.600014 0.620014 0.640015 0.660015 0.680016
0.680016 0.720016 0.720016 0.720016;
#X coords 0 1 99 -1 200 150 1 0 0;
#X restore 249 188 graph;
#X obj 58 397 expr \$0-x[$f1];
#X floatatom 58 363 5 0 99 0 - - - 0;
#X floatatom 58 433 5 0 0 0 - - - 0;
#X obj 767 406 value x\$0;
#X obj 809 374 value y_\$0;
#X obj 590 354 expr x\$0 \; y_\$0;
#X msg 767 376 1.3;
#X msg 809 344 4.7;
#X obj 767 304 loadbang;
#X obj 590 323 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X floatatom 650 403 5 0 0 0 - - - 0;
#X floatatom 590 403 5 0 0 0 - - - 0;
#X text 514 245 A simpler practice that will always work for both table
names and variables is to just have '\$0' after a symbol character
\, such as:;
#X text 33 200 On the other hand \, the '-' character is used for the
subtraction operator. Thus \, '\$0-x' is interpreted as "ID number"
minus 'x' in the [expr] object below and not as the array name to the
right., f 27;
#X text 198 378 This does load the object even though "\$0-x" doesn't
correspond to the array name. But see how the Pd window gives an error
that it can't find the 'x' table when trying to produce an output.
, f 40;
#X text 500 23 A solution for such array name issues is to send the
table name as a symbol input. But this doesn't deal with variable names
as they can't be loaded as symbols!;
#X text 542 127 try now =>;
#X text 100 362 <= try;
#X text 57 458 error;
#X text 670 184 (works);
#X text 21 6 '\$0' - the patch ID number used to force locality in
Pd - may be used in the definition local array names in [expr] \, [expr~]
or [fexpr~]. You can also use it to set local variable names in value
objects that are retrieved in [expr] \, [expr~] and [fexpr~]. This
is specially useful in abstractions., f 62;
#X text 21 89 But it is important to note the restrictions of adopting
the C-style expression syntax \, where symbols cannot start with a
number \, so '\$0x' or '\$0_x' are illegal as Pd turns '\$0' into a
number and thus the object won't load giving a syntax error!, f 62
;
#X connect 0 0 3 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 4 0 1 0;
#X connect 6 0 8 0;
#X connect 7 0 6 0;
#X connect 11 0 17 0;
#X connect 11 1 16 0;
#X connect 12 0 9 0;
#X connect 13 0 10 0;
#X connect 14 0 12 0;
#X connect 14 0 13 0;
#X connect 15 0 11 0;
#X restore 475 524 pd Dealing_with_"\$0";
#X text 18 609 see also:;
#X obj 92 660 block~;
#X obj 146 660 value;
#N canvas 421 110 489 525 All_functions 0;
#N canvas 497 97 374 326 Arithmetic-operators 0;
#X obj 57 90 expr $f1 + 4;
#X floatatom 57 63 5 0 0 0 - - - 0;
#X floatatom 57 118 5 0 0 0 - - - 0;
#X floatatom 208 63 5 0 0 0 - - - 0;
#X floatatom 208 118 5 0 0 0 - - - 0;
#X obj 208 90 expr $f1 * 4;
#X floatatom 57 197 5 0 0 0 - - - 0;
#X floatatom 57 252 5 0 0 0 - - - 0;
#X floatatom 208 197 5 0 0 0 - - - 0;
#X floatatom 208 252 5 0 0 0 - - - 0;
#X obj 57 224 expr $f1 - 1;
#X obj 208 224 expr $f1 / 10;
#X text 57 34 Add;
#X text 206 34 Multiply;
#X text 206 174 Divide;
#X text 56 174 Subtract;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 3 0 5 0;
#X connect 5 0 4 0;
#X connect 6 0 10 0;
#X connect 8 0 11 0;
#X connect 10 0 7 0;
#X connect 11 0 9 0;
#X restore 165 136 pd Arithmetic-operators;
#N canvas 513 126 621 391 Bitwise-operators 0;
#X floatatom 47 218 5 0 0 0 - - - 0;
#X obj 47 188 expr ~ $f1;
#X floatatom 44 103 5 0 0 0 - - - 0;
#X obj 44 73 expr $f1 & 3;
#X floatatom 44 43 5 0 0 0 - - - 0;
#X text 104 41 Bitwise And;
#X floatatom 347 98 5 0 0 0 - - - 0;
#X floatatom 347 38 5 0 0 0 - - - 0;
#X obj 347 68 expr $f1 << 1;
#X floatatom 349 207 5 0 0 0 - - - 0;
#X floatatom 349 147 5 0 0 0 - - - 0;
#X text 404 147 Bitshift Right;
#X text 413 36 Bitshift Left;
#X obj 349 177 expr $f1 >> 2;
#X floatatom 353 320 5 0 0 0 - - - 0;
#X floatatom 353 260 5 0 0 0 - - - 0;
#X obj 353 290 expr $f1 ^ 1;
#X text 409 260 Bitwise Exclusive Or;
#X floatatom 52 324 5 0 0 0 - - - 0;
#X floatatom 52 264 5 0 0 0 - - - 0;
#X text 114 256 Bitwise Or;
#X obj 52 294 expr $f1 | 3;
#X floatatom 47 158 5 0 0 0 - - - 0;
#X text 97 155 Bitwise Not;
#X text 141 187 (one's complement);
#X connect 1 0 0 0;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 7 0 8 0;
#X connect 8 0 6 0;
#X connect 10 0 13 0;
#X connect 13 0 9 0;
#X connect 15 0 16 0;
#X connect 16 0 14 0;
#X connect 19 0 21 0;
#X connect 21 0 18 0;
#X connect 22 0 1 0;
#X restore 165 167 pd Bitwise-operators;
#N canvas 444 131 689 317 Comparison-operators 0;
#X floatatom 48 55 5 0 0 0 - - - 0;
#X floatatom 48 110 5 0 0 0 - - - 0;
#X floatatom 199 54 5 0 0 0 - - - 0;
#X floatatom 199 109 5 0 0 0 - - - 0;
#X floatatom 55 194 5 0 0 0 - - - 0;
#X floatatom 55 249 5 0 0 0 - - - 0;
#X floatatom 351 58 5 0 0 0 - - - 0;
#X floatatom 351 113 5 0 0 0 - - - 0;
#X obj 48 82 expr $f1 > 4;
#X obj 199 81 expr $f1 < 4;
#X obj 55 221 expr $f1 >= 1;
#X text 207 26 Less than;
#X text 48 26 Greater than;
#X text 50 148 Greater than;
#X text 57 166 or equal;
#X floatatom 203 195 5 0 0 0 - - - 0;
#X floatatom 203 250 5 0 0 0 - - - 0;
#X text 206 167 or equal;
#X text 202 149 Less than;
#X obj 203 222 expr $f1 <= 10;
#X text 356 25 Equal;
#X obj 351 85 expr $f1 == 2;
#X floatatom 497 58 5 0 0 0 - - - 0;
#X floatatom 497 113 5 0 0 0 - - - 0;
#X text 502 25 Not Equal;
#X obj 497 85 expr $f1 != 2;
#X floatatom 360 191 5 0 0 0 - - - 0;
#X floatatom 360 246 5 0 0 0 - - - 0;
#X text 365 158 Logical And;
#X obj 360 218 expr $f1 && 1;
#X floatatom 498 191 5 0 0 0 - - - 0;
#X floatatom 498 246 5 0 0 0 - - - 0;
#X text 503 158 Logical Or;
#X obj 498 218 expr $f1 || 0;
#X connect 0 0 8 0;
#X connect 2 0 9 0;
#X connect 4 0 10 0;
#X connect 6 0 21 0;
#X connect 8 0 1 0;
#X connect 9 0 3 0;
#X connect 10 0 5 0;
#X connect 15 0 19 0;
#X connect 19 0 16 0;
#X connect 21 0 7 0;
#X connect 22 0 25 0;
#X connect 25 0 23 0;
#X connect 26 0 29 0;
#X connect 29 0 27 0;
#X connect 30 0 33 0;
#X connect 33 0 31 0;
#X restore 165 198 pd Comparison-operators;
#N canvas 458 88 472 464 If-function 0;
#X floatatom 82 53 5 0 0 0 - - - 0;
#X floatatom 82 112 5 0 0 0 - - - 0;
#X floatatom 87 218 5 0 0 0 - - - 0;
#X floatatom 87 277 5 0 0 0 - - - 0;
#X text 142 213 if(condition \, true \, false);
#X obj 87 246 expr if($f1 > 0 \, $f1 * 10 \, $f1 - 1);
#X floatatom 59 346 5 0 0 0 - - - 0;
#X floatatom 59 405 5 0 0 0 - - - 0;
#X obj 59 374 expr if($f1 > 10 \, 10 \, if($f1 < -10 \, -10 \, $f1))
;
#X text 118 404 <= clips at -10 and 10;
#X obj 82 81 expr if($f1 >= 0 \, 1 \, -1);
#X text 53 21 Syntax: if(condition \, true \, false);
#X text 143 325 You can also nest an if function as a true/false expression:
, f 32;
#X text 39 163 It accepts expressions as true/false as well:;
#X connect 0 0 10 0;
#X connect 2 0 5 0;
#X connect 5 0 3 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 10 0 1 0;
#X restore 165 231 pd If-function;
#N canvas 444 91 491 376 Random-function 0;
#X floatatom 107 206 5 0 0 0 - - - 0;
#X obj 107 175 expr random(10 \, 20);
#X obj 107 147 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X text 133 142 random values from 10 to 19;
#X floatatom 108 306 5 0 0 0 - - - 0;
#X obj 108 247 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X obj 108 275 expr random(-100 \, 101);
#X text 134 242 random values from -100 to 100;
#X text 36 32 The random function generates random numbers within a
given range \, specified by the two arguments. The range is from the
first argument to the second argument minus one., f 51;
#X connect 1 0 0 0;
#X connect 2 0 1 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X restore 165 262 pd Random-function;
#N canvas 558 74 604 529 Table-functions 0;
#X obj 63 73 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X floatatom 63 163 0 0 0 0 - - - 0;
#X floatatom 145 164 0 0 0 0 - - - 0;
#X floatatom 228 164 0 0 0 0 - - - 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array table 100 float 1;
#A 0 0 1 2 3 4 5 6 7 8 9 18.5714 21.4285 28.5713 31.4284 34.9998 38.5712
40.714 42.8569 46.4283 49.2854 50.3568 51.4282 53.5711 54.2853 54.9996
55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.7139 55.5353
55.3568 55.1782 54.9996 54.2853 53.5711 52.8568 52.1425 51.4282 49.9997
48.5711 47.1426 45.714 44.0473 42.3807 40.714 39.0474 37.3807 35.7141
32.857 31.4284 29.9999 28.5713 26.4285 26.4285 26.7856 27.1427 27.857
28.5713 29.107 29.6427 30.1784 30.7141 31.607 32.4998 33.3927 34.2855
34.9998 35.7141 36.6665 37.6188 38.5712 40.714 41.4283 42.1426 44.2854
45.714 46.7854 47.8568 49.9997 51.4282 52.8568 55.7139 57.8567 59.9996
62.8567 64.9995 66.4281 69.2852 72.1423 93 94 95 96 97 98 99;
#X coords 0 100 99 0 200 140 1 0 0;
#X restore 336 118 graph;
#X obj 364 422 expr size("$s1") \;;
#X obj 63 102 expr Sum("table" \, 3 \, 9) \; sum("table") \; size("table")
;
#X msg 364 392 symbol table;
#X floatatom 364 455 5 0 0 0 - - - 0;
#X text 64 187 Sums a range of indexes, f 8;
#X text 146 189 Sums all indexes, f 8;
#X text 225 189 Gives array size, f 5;
#X obj 47 269 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X floatatom 47 344 0 0 0 0 - - - 0;
#X floatatom 240 344 0 0 0 0 - - - 0;
#X obj 47 396 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X floatatom 47 469 0 0 0 0 - - - 0;
#X floatatom 212 467 0 0 0 0 - - - 0;
#X obj 47 299 expr avg("table") \; sum("table") / size("table");
#X obj 47 424 expr Avg("table" \, 3 \, 9) \; Sum("table" \, 3 \, 9)
/ 7;
#X text 71 267 avg - Averages all indexes;
#X text 71 394 Avg - averages a range of indexes;
#X text 114 26 There are 5 functions that operate on arrays: Avg \,
avg \, Sum \, sum and size., f 45;
#X text 354 286 You can use a symbol type to specify the array name.
Note that the syntax requires that the array name is inside quotes.
, f 23;
#X connect 0 0 6 0;
#X connect 5 0 8 0;
#X connect 6 0 1 0;
#X connect 6 1 2 0;
#X connect 6 2 3 0;
#X connect 7 0 5 0;
#X connect 12 0 18 0;
#X connect 15 0 19 0;
#X connect 18 0 13 0;
#X connect 18 1 14 0;
#X connect 19 0 16 0;
#X connect 19 1 17 0;
#X restore 165 331 pd Table-functions;
#N canvas 576 55 570 578 Power-functions 0;
#X floatatom 62 60 5 0 0 0 - - - 0;
#X floatatom 62 119 5 0 0 0 - - - 0;
#X floatatom 62 151 5 0 0 0 - - - 0;
#X floatatom 62 208 5 0 0 0 - - - 0;
#X floatatom 59 337 5 0 0 0 - - - 0;
#X floatatom 59 409 0 0 0 0 - - - 0;
#X floatatom 306 103 5 0 0 0 - - - 0;
#X floatatom 394 101 5 0 0 0 - - - 0;
#X floatatom 306 31 5 0 0 0 - - - 0;
#X floatatom 308 414 5 0 0 0 - - - 0;
#X floatatom 308 484 0 0 0 0 - - - 0;
#X floatatom 62 513 5 0 0 0 - - - 0;
#X obj 62 88 expr pow($f1 \, 2);
#X floatatom 306 276 5 0 0 0 - - - 0;
#X floatatom 306 224 5 0 0 0 - - - 0;
#X obj 306 56 expr ln($f1) \; log($f1);
#X obj 62 484 expr fact($f1);
#X msg 62 451 3;
#X floatatom 403 482 0 0 0 0 - - - 0;
#X floatatom 154 408 0 0 0 0 - - - 0;
#X floatatom 307 187 5 0 0 0 - - - 0;
#X floatatom 307 135 5 0 0 0 - - - 0;
#X obj 307 160 expr log1p($f1);
#X obj 306 249 expr log10($f1);
#X floatatom 309 375 5 0 0 0 - - - 0;
#X floatatom 309 323 5 0 0 0 - - - 0;
#X obj 309 348 expr ldexp($f1 \, 3);
#X obj 59 365 expr exp($f1) \; expm1($f1);
#X floatatom 61 239 5 0 0 0 - - - 0;
#X floatatom 61 296 5 0 0 0 - - - 0;
#X obj 62 179 expr sqrt($f1);
#X obj 61 267 expr cbrt($f1);
#X text 171 382 exp - 1;
#X text 235 507 error function;
#X text 402 505 complementary error function, f 14;
#X obj 308 442 expr erf($f1) \; erfc($f1);
#X text 64 33 Raise to the power of;
#X text 129 148 Square root;
#X text 138 239 Cube root;
#X text 121 324 Exp: 'e' raised to the power of, f 15;
#X text 98 451 Factorial;
#X text 353 29 Natural log;
#X text 365 133 Natural log of input + 1;
#X text 353 221 Log base 10;
#X text 364 307 Multiply by integral power of 2, f 20;
#X text 368 409 Error functions;
#X text 112 54 second argument;
#X connect 0 0 12 0;
#X connect 2 0 30 0;
#X connect 4 0 27 0;
#X connect 8 0 15 0;
#X connect 9 0 35 0;
#X connect 12 0 1 0;
#X connect 14 0 23 0;
#X connect 15 0 6 0;
#X connect 15 1 7 0;
#X connect 16 0 11 0;
#X connect 17 0 16 0;
#X connect 21 0 22 0;
#X connect 22 0 20 0;
#X connect 23 0 13 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 27 0 5 0;
#X connect 27 1 19 0;
#X connect 28 0 31 0;
#X connect 30 0 3 0;
#X connect 31 0 29 0;
#X connect 35 0 10 0;
#X connect 35 1 18 0;
#X restore 165 364 pd Power-functions;
#N canvas 411 157 849 422 Trigonometric-functions 0;
#X floatatom 34 54 5 0 0 0 - - - 0;
#X floatatom 34 113 5 0 0 0 - - - 0;
#X floatatom 34 145 5 0 0 0 - - - 0;
#X floatatom 34 202 5 0 0 0 - - - 0;
#X floatatom 33 233 5 0 0 0 - - - 0;
#X floatatom 33 290 5 0 0 0 - - - 0;
#X obj 34 82 expr sin($f1);
#X obj 34 173 expr cos($f1);
#X obj 33 261 expr tan($f1);
#X floatatom 194 54 5 0 0 0 - - - 0;
#X floatatom 194 113 5 0 0 0 - - - 0;
#X floatatom 194 145 5 0 0 0 - - - 0;
#X floatatom 194 202 5 0 0 0 - - - 0;
#X obj 194 82 expr asin($f1);
#X obj 194 173 expr acos($f1);
#X text 83 52 sine;
#X text 85 145 cosine;
#X text 84 233 tangent;
#X floatatom 195 229 5 0 0 0 - - - 0;
#X floatatom 195 286 5 0 0 0 - - - 0;
#X text 261 52 arc sine;
#X text 256 145 arc cosine;
#X text 256 229 arc tangent;
#X floatatom 387 53 5 0 0 0 - - - 0;
#X floatatom 387 112 5 0 0 0 - - - 0;
#X floatatom 387 144 5 0 0 0 - - - 0;
#X floatatom 387 201 5 0 0 0 - - - 0;
#X floatatom 388 228 5 0 0 0 - - - 0;
#X floatatom 388 285 5 0 0 0 - - - 0;
#X floatatom 264 329 5 0 0 0 - - - 0;
#X floatatom 264 386 5 0 0 0 - - - 0;
#X obj 264 357 expr atan2($f1 \, $f2);
#X floatatom 401 329 5 0 0 0 - - - 0;
#X text 426 357 arc tangent of 2 variables;
#X obj 195 257 expr atan($f1);
#X floatatom 617 53 5 0 0 0 - - - 0;
#X floatatom 617 112 5 0 0 0 - - - 0;
#X floatatom 617 144 5 0 0 0 - - - 0;
#X floatatom 617 201 5 0 0 0 - - - 0;
#X floatatom 618 228 5 0 0 0 - - - 0;
#X floatatom 618 285 5 0 0 0 - - - 0;
#X text 741 66 inverse hyperbolic sine, f 10;
#X obj 617 81 expr asinh($f1);
#X obj 617 172 expr acosh($f1);
#X obj 618 256 expr atanh($f1);
#X text 742 157 inverse hyperbolic cosine, f 10;
#X text 743 245 inverse hyperbolic tangent, f 10;
#X obj 387 81 expr sinh($f1);
#X obj 387 172 expr cosh($f1);
#X obj 388 256 expr tanh($f1);
#X text 503 255 hyperbolic tangent, f 10;
#X text 502 167 hyperbolic cosine, f 10;
#X text 501 76 hyperbolic sine, f 10;
#X text 112 12 All trigonometric functions expect the input in radians
(except the arc or inverse ones)., f 89;
#X connect 0 0 6 0;
#X connect 2 0 7 0;
#X connect 4 0 8 0;
#X connect 6 0 1 0;
#X connect 7 0 3 0;
#X connect 8 0 5 0;
#X connect 9 0 13 0;
#X connect 11 0 14 0;
#X connect 13 0 10 0;
#X connect 14 0 12 0;
#X connect 18 0 34 0;
#X connect 23 0 47 0;
#X connect 25 0 48 0;
#X connect 27 0 49 0;
#X connect 29 0 31 0;
#X connect 31 0 30 0;
#X connect 32 0 31 1;
#X connect 34 0 19 0;
#X connect 35 0 42 0;
#X connect 37 0 43 0;
#X connect 39 0 44 0;
#X connect 42 0 36 0;
#X connect 43 0 38 0;
#X connect 44 0 40 0;
#X connect 47 0 24 0;
#X connect 48 0 26 0;
#X connect 49 0 28 0;
#X restore 165 397 pd Trigonometric-functions;
#N canvas 332 23 592 281 Store-function 0;
#X text 40 26 The store function is defined with "=" \, and it can
store the result of any operation into a variable or table index.;
#X obj 62 129 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X floatatom 62 211 5 0 0 0 - - - 0;
#X floatatom 276 204 5 0 0 0 - - - 0;
#X obj 62 158 expr array2[inc - 1] = 1 / inc \; inc = inc + 1;
#N canvas 0 22 450 278 (subpatch) 0;
#X array array2 16 float 2;
#X coords 0 1.1 16 -0.1 200 140 1 0 0;
#X restore 351 101 graph;
#X obj 129 119 v inc;
#X msg 129 94 0;
#X connect 1 0 4 0;
#X connect 4 0 2 0;
#X connect 4 1 3 0;
#X connect 7 0 6 0;
#X restore 165 296 pd Store-function;
#X text 46 19 Here are all the operators and functions available for
[expr] \, [expr~] and [fexpr~] \, even though the given examples are
only presented with [expr]., f 52;
#X text 46 76 These are organized in different groups. Click on the
subpatches below to check each group:, f 52;
#N canvas 385 128 850 540 Other-functions 0;
#X floatatom 54 26 5 0 0 0 - - - 0;
#X floatatom 54 99 5 0 0 0 - - - 0;
#X text 163 54 convert to int;
#X floatatom 49 272 5 0 0 0 - - - 0;
#X floatatom 49 362 5 0 0 0 - - - 0;
#X text 102 142 convert to float;
#X floatatom 50 217 5 0 0 0 - - - 0;
#X floatatom 194 215 5 0 0 0 - - - 0;
#X floatatom 50 143 5 0 0 0 - - - 0;
#X floatatom 342 32 5 0 0 0 - - - 0;
#X floatatom 342 108 5 0 0 0 - - - 0;
#X floatatom 458 105 5 0 0 0 - - - 0;
#X obj 342 60 expr max($f1 \, 0) \; min($f1 \, 0);
#X text 394 30 maximum / minimum;
#X obj 321 172 expr copysign($f1 \, $f2);
#X floatatom 479 149 5 0 0 0 - - - 0;
#X floatatom 321 147 5 0 0 0 - - - 0;
#X floatatom 321 201 5 0 0 0 - - - 0;
#X text 367 200 copy sign of a number;
#X obj 50 170 expr float($i1) / 10 \; float(5) / 10 \;;
#X floatatom 593 164 5 0 0 0 - - - 0;
#X floatatom 702 163 5 0 0 0 - - - 0;
#X obj 593 119 expr isinf($f1) \; finite($f1);
#X text 721 117 "is infinite" and "is finite", f 15;
#X floatatom 593 87 5 0 0 0 - - - 0;
#X msg 633 29 2;
#X obj 593 54 pow 1e+10;
#X msg 593 27 1;
#X floatatom 601 347 5 0 0 0 - - - 0;
#X floatatom 601 285 5 0 0 0 - - - 0;
#X obj 601 315 expr isnan($f1);
#X text 722 295 "is Nan" (not a number), f 8;
#X floatatom 341 242 5 0 0 0 - - - 0;
#X floatatom 341 311 5 0 0 0 - - - 0;
#X obj 54 54 expr int($f1) \; trunc($f1);
#X floatatom 149 99 5 0 0 0 - - - 0;
#X text 163 69 truncate a float;
#X floatatom 100 362 5 0 0 0 - - - 0;
#X floatatom 151 362 5 0 0 0 - - - 0;
#X obj 49 303 expr rint($f1) \; round($f1) \; nearbyint($f1);
#X floatatom 322 415 5 0 0 0 - - - 0;
#X floatatom 322 495 5 0 0 0 - - - 0;
#X floatatom 387 495 5 0 0 0 - - - 0;
#X floatatom 52 421 5 0 0 0 - - - 0;
#X floatatom 52 494 5 0 0 0 - - - 0;
#X floatatom 154 494 5 0 0 0 - - - 0;
#X text 101 420 ceil / floor;
#X obj 52 449 expr ceil($f1) \; floor($f1);
#X obj 341 268 expr imodf($f1) \; modf($f1);
#X text 325 332 get signed integer, f 10;
#X text 435 334 get signed fractional, f 11;
#X floatatom 450 311 5 0 0 0 - - - 0;
#X floatatom 632 400 5 0 0 0 - - - 0;
#X obj 632 437 expr abs($f1);
#X floatatom 632 474 5 0 0 0 - - - 0;
#X text 680 399 absolute value;
#X obj 601 225 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X msg 322 384 7;
#X obj 601 251 expr log(-1);
#X text 100 264 round floats to integers, f 12;
#X floatatom 452 495 5 0 0 0 - - - 0;
#X msg 289 384 -7;
#X text 458 440 (integer);
#X text 458 454 (float);
#X obj 322 440 expr $f1 % 4 \; fmod($f1 \, 4.1) \; remainder($f1 \,
4.1);
#X text 371 412 remainder functions;
#X text 105 27 convert to integers;
#X connect 0 0 34 0;
#X connect 3 0 39 0;
#X connect 8 0 19 0;
#X connect 9 0 12 0;
#X connect 12 0 10 0;
#X connect 12 1 11 0;
#X connect 14 0 17 0;
#X connect 15 0 14 1;
#X connect 16 0 14 0;
#X connect 19 0 6 0;
#X connect 19 1 7 0;
#X connect 22 0 20 0;
#X connect 22 1 21 0;
#X connect 24 0 22 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 27 0 26 0;
#X connect 29 0 30 0;
#X connect 30 0 28 0;
#X connect 32 0 48 0;
#X connect 34 0 1 0;
#X connect 34 1 35 0;
#X connect 39 0 4 0;
#X connect 39 1 37 0;
#X connect 39 2 38 0;
#X connect 40 0 64 0;
#X connect 43 0 47 0;
#X connect 47 0 44 0;
#X connect 47 1 45 0;
#X connect 48 0 33 0;
#X connect 48 1 51 0;
#X connect 52 0 53 0;
#X connect 53 0 54 0;
#X connect 56 0 58 0;
#X connect 57 0 40 0;
#X connect 58 0 29 0;
#X connect 61 0 40 0;
#X connect 64 0 41 0;
#X connect 64 1 42 0;
#X connect 64 2 60 0;
#X restore 164 462 pd Other-functions;
#N canvas 802 216 564 371 Acousticts 0;
#X floatatom 70 109 0 0 0 0 - - - 0;
#X floatatom 70 164 0 0 0 0 - - - 0;
#X floatatom 70 213 0 0 0 0 - - - 0;
#X obj 70 137 expr mtof($f1);
#X obj 70 189 expr ftom($f1);
#X floatatom 216 109 0 0 0 0 - - - 0;
#X floatatom 216 164 0 0 0 0 - - - 0;
#X floatatom 216 213 0 0 0 0 - - - 0;
#X floatatom 377 112 0 0 0 0 - - - 0;
#X floatatom 377 167 0 0 0 0 - - - 0;
#X floatatom 377 216 0 0 0 0 - - - 0;
#X obj 216 137 expr dbtorms($f1);
#X obj 216 189 expr rmstodb($f1);
#X obj 63 314 mtof;
#X obj 119 314 ftom;
#X obj 175 315 dbtorms;
#X obj 251 315 rmstodb;
#X obj 330 315 dbtopow;
#X obj 407 315 powtodb;
#X text 63 279 See also:;
#X obj 377 140 expr dbtopow($f1);
#X obj 377 192 expr powtodb($f1);
#X text 63 77 MTDI x Hertz;
#X text 79 33 Acoustic conversions;
#X text 238 81 dB x RMS;
#X text 396 82 dB x Power;
#X connect 0 0 3 0;
#X connect 1 0 4 0;
#X connect 3 0 1 0;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 12 0;
#X connect 8 0 20 0;
#X connect 9 0 21 0;
#X connect 11 0 6 0;
#X connect 12 0 7 0;
#X connect 20 0 9 0;
#X connect 21 0 10 0;
#X restore 164 430 pd Acousticts;
#X restore 475 549 pd All_functions \; and operators;
#N canvas 398 62 968 659 [expr] 0;
#X obj 206 123 expr 1;
#X floatatom 206 153 4 0 0 0 - - - 0;
#X msg 206 95 bang;
#X msg 307 96 bang;
#X floatatom 307 151 4 0 0 0 - - - 0;
#X floatatom 52 383 0 0 0 0 - - - 0;
#X floatatom 557 49 0 0 0 0 - - - 0;
#X floatatom 557 125 0 0 0 0 - - - 0;
#X floatatom 573 344 0 0 0 0 - - - 0;
#X obj 573 316 expr 8 / 3;
#X floatatom 707 583 0 0 0 0 - - - 0;
#X obj 573 292 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X obj 707 495 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X floatatom 768 583 0 0 0 0 - - - 0;
#X obj 557 77 expr cos(2 * 3.14159 * $f1 / 360) \; sin(2 * 3.14159
* $f1 / 360);
#X floatatom 792 125 0 0 0 0 - - - 0;
#X floatatom 308 450 5 0 0 0 - - - 0;
#X floatatom 308 558 5 0 0 0 - - - 0;
#X floatatom 352 557 5 0 0 0 - - - 0;
#X floatatom 396 557 5 0 0 0 - - - 0;
#X obj 352 597 print expr;
#X obj 52 352 expr ($f1 + 2) * $i2;
#X text 71 111 A bang evaluates the expression, f 17;
#X text 599 48 example of trigonometric functions;
#X floatatom 793 345 0 0 0 0 - - - 0;
#X msg 793 293 8;
#X obj 793 317 expr $f1 / 3;
#X text 542 537 '8.' becomes a float =>;
#X floatatom 679 344 0 0 0 0 - - - 0;
#X msg 679 292 8;
#X obj 679 316 expr $i1 / 3;
#X text 508 210 Integer numbers inside the [expr] object are interpreted
as integers \, not floats. Hence \, the result of the division below
to the left is also an integer and it's the same if you have an '$i#'
variable \, but '$f#' works fine.;
#X obj 707 521 expr float(8) / 3 \; (8.) / 3 \; 8./3;
#X floatatom 830 583 0 0 0 0 - - - 0;
#X text 542 551 also becomes a float =>;
#X obj 307 123 expr 2 + 3.2;
#X text 496 180 NOTE About integers and integer variable types:;
#X text 30 31 Here are some basic examples of the [expr] object. This
object only takes the variables: "$f#" \, "$i#" and "$s#" (examples
of this type are presented in [pd Arrays] in the parent patch)., f
63;
#X obj 157 316 t b f;
#X floatatom 52 289 6 0 0 0 - - - 0;
#X floatatom 157 289 6 0 0 0 - - - 0;
#X text 28 202 '$f1' is a float from the 1st inlet \, '$i2' is an integer
from the second inlet (so float input values are truncated to integers).
;
#X obj 308 486 expr $f1 + 1 \; $f1 - 1 \; $f1 * 2 + 1;
#X text 222 341 See how '()' is used to force an operation priority
for the sum. Otherwise '*' and '/' have priority., f 33;
#X text 219 283 Note that a bang also evaluates the expression with
the previously set values., f 34;
#X text 57 470 A semicolon can be used to create and separate different
expressions (up to 100). If so \, an outlet is created for each expression
and they're evaluated from right to left (or bottom to up) order:,
f 30;
#X text 507 390 Pd turns "8.0" into "8" and [expr] will see it as an
integer. One way to deal with this is with the "float" function to
convert an integer to a float. A possible workaround is to have just
a decimal point and the number inside parenthesis. Pd sees this as
a symbol and doesn't remove the dot and [expr] will see it as a float.
Other hacks like that are possible \, see below:, f 61;
#X connect 0 0 1 0;
#X connect 2 0 0 0;
#X connect 3 0 35 0;
#X connect 6 0 14 0;
#X connect 9 0 8 0;
#X connect 11 0 9 0;
#X connect 12 0 32 0;
#X connect 14 0 7 0;
#X connect 14 1 15 0;
#X connect 16 0 42 0;
#X connect 17 0 20 0;
#X connect 18 0 20 0;
#X connect 19 0 20 0;
#X connect 21 0 5 0;
#X connect 25 0 26 0;
#X connect 26 0 24 0;
#X connect 29 0 30 0;
#X connect 30 0 28 0;
#X connect 32 0 10 0;
#X connect 32 1 13 0;
#X connect 32 2 33 0;
#X connect 35 0 4 0;
#X connect 38 0 21 0;
#X connect 38 1 21 1;
#X connect 39 0 21 0;
#X connect 40 0 38 0;
#X connect 42 0 17 0;
#X connect 42 1 18 0;
#X connect 42 2 19 0;
#X restore 226 500 pd [expr] Examples;
#N canvas 491 51 875 695 [expr~] 0;
#X floatatom 80 361 0 0 0 0 - - - 0;
#X obj 80 468 dac~;
#X text 125 361 frequency;
#X floatatom 685 260 0 0 10 0 - - - 0;
#X obj 478 329 tabsend~ a1;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a1 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 627 352 graph;
#X obj 88 644 tabsend~ a2;
#X obj 253 640 tabsend~ a3;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a2 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 408 525 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a3 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 630 525 graph;
#X obj 80 388 osc~ 440;
#X obj 283 332 hsl 128 15 0 127 0 0 empty empty empty -2 -8 0 10 #fcfcfc
#000000 #000000 0 1;
#X floatatom 280 352 5 0 0 0 - - - 0;
#X text 331 352 amplitude;
#X obj 280 399 line~;
#X obj 80 429 expr~ $v1 * pow($v2 / 127 \, 4);
#X obj 88 594 expr~ $v1 * $v2 \; if ($v2 > 0 \, 0 \, $v1*$v2);
#X obj 88 561 osc~ 440;
#X obj 478 252 osc~ 440;
#X obj 478 290 expr~ max(min($v1 \, $f2) \, -$f2);
#X obj 685 145 vsl 20 100 0 1 0 0 empty empty empty 0 -9 0 10 #fcfcfc
#000000 #000000 0 1;
#X text 460 187 Move the slider to change the limiter threshold (from
0-1)., f 29;
#X text 64 34 make sure to turn on the audio for the [expr~] examples
====>, f 30;
#X obj 177 299 print~;
#X msg 195 270 bang;
#X floatatom 279 209 0 0 0 0 - - - 0;
#X floatatom 177 184 0 0 0 0 - - - 0;
#X obj 177 211 sig~ 1;
#X obj 253 561 osc~ 550;
#X text 458 163 A simple limiter/clip example:;
#X text 82 218 Examples:;
#X text 468 37 NOTE: The vector/block size can be set with the [block~]
or [switch~] objects \, and is 64 samples by default., f 43;
#X msg 280 375 \$1 20;
#X obj 664 90 block~ 64;
#X text 589 90 see also:;
#X obj 177 239 expr~ $v1 + $v2;
#X text 22 105 Besides '$f#' \, '$i#' and '$s#' \, [expr~] takes '$v#'
variables. Note that the first inlet of [expr~] needs to be of type
'$v1'. You can still send floats to this left inlet as floats sent
to audio inlets are promoted to signals., f 54;
#X msg 290 55 \; pd dsp \$1;
#X obj 290 30 tgl 17 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000 0 1;
#X text 83 512 a semicolon also creates more expressions and outlets
(up to 100), f 35;
#X connect 0 0 10 0;
#X connect 3 0 19 1;
#X connect 10 0 15 0;
#X connect 11 0 12 0;
#X connect 12 0 32 0;
#X connect 14 0 15 1;
#X connect 15 0 1 0;
#X connect 15 0 1 1;
#X connect 16 0 6 0;
#X connect 16 1 7 0;
#X connect 17 0 16 0;
#X connect 18 0 19 0;
#X connect 19 0 4 0;
#X connect 20 0 3 0;
#X connect 24 0 23 0;
#X connect 25 0 35 1;
#X connect 26 0 27 0;
#X connect 27 0 35 0;
#X connect 28 0 16 1;
#X connect 32 0 14 0;
#X connect 35 0 23 0;
#X connect 38 0 37 0;
#X restore 219 528 pd [expr~] Examples;
#N canvas 240 37 1094 690 [fexpr~] 0;
#X text 90 365 - $x1: same as $x1[0] \, $x2: same as $x2[0] (and so
on)., f 60;
#X text 90 347 - $x: same as $x1[0]., f 60;
#X text 90 383 - $y: same as $y1[-1]., f 60;
#X text 90 401 - $y1: same as $y1[-1] \, $y2: same as $y2[-1] (and
so on)., f 60;
#X msg 670 165 start;
#X msg 618 165 stop;
#X obj 618 135 loadbang;
#X msg 739 162 set 4000;
#X obj 726 128 sig~ 0.001;
#X obj 726 230 fexpr~ $x1[0] + $y1[-1];
#X msg 753 196 clear y1;
#X text 820 196 clears output buffer;
#X obj 726 268 snapshot~;
#X obj 590 220 metro 100;
#X obj 590 198 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000 0 1;
#X floatatom 726 293 8 0 0 0 - - - 0;
#X text 806 127 increment value;
#X text 804 161 set last output value ($y1[-1]);
#X text 83 605 - clear: clears all the previous input and output buffers
, f 60;
#X text 83 569 - clear x#: clears the previous values of the #th input
, f 60;
#X text 83 587 - clear y#: clears the previous values of the #th output
, f 60;
#X text 83 490 - set y# <list>: sets the as many supplied values of
the #th output (e.g. "set y3 1 2" sets $y3[-1] = 1 and $y3[-2] = 2).
;
#X floatatom 841 517 5 0 0 0 - - - 0;
#X msg 642 483 start;
#X msg 596 483 stop;
#X obj 596 450 loadbang;
#X msg 802 479 0;
#X obj 697 553 fexpr~ $x1 + $x1[$f2];
#X msg 697 425 1102.5;
#X floatatom 697 483 0 0 0 0 - - - 0;
#X text 556 342 Simple FIR filter:, f 58;
#X msg 881 479 -20;
#X msg 841 479 -10;
#X text 779 433 change values to filter the frequencies, f 23;
#X text 83 523 - set <list>: sets the first past values of each output
(e.g. "set 0.1 2.2 0.4" sets y1[-1] = 0.1 \, y2[-1] = 2.2 \, and y3[-1]
= 0.4).;
#X text 83 458 - set x# <list>: sets as many supplied values of the
#th input (e.g. "set x2 1 2" sets $x2[0] = 1 and $x2[-1] = 2)., f
60;
#X text 561 85 Simple accumulator example:;
#X text 49 433 [fexpr~] responds to the following methods:, f 63;
#X text 113 162 - $y#[n]: output sample of outlet # indexed by 'n'
;
#X text 113 143 - $x#[n]: input sample of inlet # indexed by 'n',
f 50;
#X text 919 578 more examples:;
#N canvas 286 64 900 597 Difference 0;
#X obj 194 193 v pr;
#X obj 341 193 v r;
#X obj 249 195 v b;
#X floatatom 194 164 5 0 0 0 - - - 0;
#X floatatom 341 166 5 0 0 0 - - - 0;
#X msg 194 139 10;
#X msg 172 251 set 1.2 2.3 4.4;
#X floatatom 249 165 7 0 0 0 - - - 0;
#X floatatom 399 166 5 0 0 0 - - - 0;
#X obj 399 195 v dt;
#X msg 341 137 18;
#X msg 399 127 0.01;
#X obj 172 65 bng 25 250 50 0 empty empty empty 20 8 0 8 #fcfcfc #000000
#000000;
#X obj 449 136 line;
#X msg 449 110 0.01 \, 0.04 5000;
#X obj 101 193 loadbang;
#N canvas 0 50 450 300 (subpatch) 0;
#X array X 64 float 0;
#X coords 0 20 63 -20 200 140 1 0 0;
#X restore 178 423 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Y 64 float 0;
#X coords 0 20 63 -20 200 140 2 0 0;
#X restore 418 421 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Z 64 float 0;
#X coords 0 40 63 0 200 140 2 0 0;
#X restore 655 420 graph;
#X obj 249 136 expr 8./3;
#X text 577 289 $y1 -> $y1[-1] $y2 -> $y2[-1] $y3 -> $y3[-1], f 15
;
#X text 145 547 -20;
#X text 152 416 20;
#X text 381 547 -20;
#X text 388 416 20;
#X text 635 547 0;
#X text 630 416 40;
#X text 624 24 Lorenz Equations written with 3 state variables X \,
Y \, and Z:, f 30;
#X text 412 301 <= Note the shorthands:;
#X text 670 67 dX/dt = pr * (Y - X);
#X text 670 87 dY/dt = X(r - Z) - Y;
#X text 670 107 dZ/dt = X*Y - bZ, f 20;
#X obj 172 285 fexpr~ $y1 + pr*($y2 - $y1) * dt \; $y2 + ($y1*(r -
$y3) - $y2) * dt \; $y3 + ($y1*$y2 - b*$y3) * dt;
#X obj 172 359 tabsend~ X;
#X obj 286 359 tabsend~ Y;
#X obj 400 360 tabsend~ Z;
#X text 294 250 <= sets initial values of $y1[-1] \, $y2[-1] \, and
$y3[-1];
#X text 108 51 bang to start =>, f 8;
#X msg 101 218 stop;
#X text 446 165 <= experiment with these parameter values. If you;
#X text 470 183 hear a click and audio stops \, the system went unstable
and you need to bang on the top again to reload the default values.
, f 46;
#X msg 43 220 start;
#X obj 67 376 output~;
#X text 241 19 This is an example of how [fexpr~] can be used to solve
differential equations such as the lorenz equations. Semicolons create
new outlets as usual (up to 100). Here we have 3 expressions \, so
we now have '$y2' and '$y3' variables., f 49;
#X connect 3 0 0 0;
#X connect 4 0 1 0;
#X connect 5 0 3 0;
#X connect 6 0 32 0;
#X connect 7 0 2 0;
#X connect 8 0 9 0;
#X connect 10 0 4 0;
#X connect 11 0 8 0;
#X connect 12 0 5 0;
#X connect 12 0 10 0;
#X connect 12 0 11 0;
#X connect 12 0 6 0;
#X connect 12 0 41 0;
#X connect 12 0 19 0;
#X connect 13 0 8 0;
#X connect 14 0 13 0;
#X connect 15 0 38 0;
#X connect 19 0 7 0;
#X connect 32 0 33 0;
#X connect 32 0 42 1;
#X connect 32 0 42 0;
#X connect 32 1 34 0;
#X connect 32 2 35 0;
#X connect 38 0 32 0;
#X connect 41 0 32 0;
#X restore 798 632 pd Difference equations (Lorenz);
#N canvas 695 185 503 409 Fractional 0;
#X msg 130 190 start;
#X msg 78 189 stop;
#X obj 78 158 loadbang;
#X obj 308 147 hsl 128 15 0 -10 0 0 empty empty empty -2 -8 0 10 #fcfcfc
#000000 #000000 0 1;
#X floatatom 305 173 0 -10 0 0 - - - 0;
#X obj 305 233 line~;
#X msg 305 203 \$1 100;
#X obj 161 222 osc~ 2205;
#X text 204 127 fractional sample index offset, f 17;
#X obj 161 264 fexpr~ $x1 + $x1[$x2];
#X text 25 16 When fractional index offset is used for either input
or output samples (with '$f#' or '$x#' variables) \, [fexpr~] determines
the value by linear interpolation., f 63;
#X text 25 68 In the following example \, you can continuously change
the sample input index from 0 to -10 (the point that filters the frequency
of 2205 Hz)., f 63;
#X obj 161 314 output~;
#X connect 0 0 9 0;
#X connect 1 0 9 0;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 5 0 9 1;
#X connect 6 0 5 0;
#X connect 7 0 9 0;
#X connect 9 0 12 0;
#X connect 9 0 12 1;
#X restore 840 604 pd Fractional sample index;
#X text 612 364 -10 offset filters audio at frequency of 2205 Hz -20
offset filters audio at frequency of 1102.5 Hz, f 50;
#X msg 714 452 2205;
#X obj 697 514 osc~ 2205;
#X text 24 26 NOTE: - [fexpr~] operates on sample level data for things
like filter design and can be very cpu intensive!, f 69;
#X obj 250 202 fexpr~ $x1[0] + $y1[-1];
#X text 181 203 example:;
#X text 23 248 'n' goes from 0 to -(vector size -1). The vector (or
'block') size is defined by the [block~] or [switch~] objects. As such
\, $x#[0] specifies the current sample input \, and $y#[-1] the last
sample output (which is the minimum 'n' value \, for $y#)., f 71;
#X text 52 325 There are shorthands as follows:;
#X text 83 623 - stop: stops the computation of [fexpr~], f 60;
#X text 83 641 - start: starts the computation of [fexpr~], f 60;
#X text 558 18 As noted \, [fexpr~] can be CPU expensive! By default
\, [fexpr~] is on when it is loaded \, but you can save CPU and control
when it is on or off with the 'start' and 'stop' messages. Below \,
you need to click 'start' to get it running., f 73;
#X msg 917 258 \; pd dsp \$1;
#X obj 917 233 tgl 17 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000 0 1;
#X obj 639 612 output~;
#X obj 924 519 declare -stdpath ./;
#X text 23 63 Besides '$f#' \, '$i#' and '$s#' \, [fexpr~] takes '$x#'
and '$y#' variables (and no '$v#' variables from [expr~]). Note that
the first inlet of [fexpr~] needs to be of type '$x1' (cannot be '$f1'
\, '$i1' or '$s1'). You can still send floats to this left inlet as
floats sent to audio inlets are promoted to signals. The '$x#' and
'$y#' types are:, f 71;
#X text 938 233 <= make DSP is on, f 18;
#X connect 4 0 9 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 6 0 14 0;
#X connect 7 0 9 0;
#X connect 8 0 9 0;
#X connect 9 0 12 0;
#X connect 10 0 9 0;
#X connect 12 0 15 0;
#X connect 13 0 12 0;
#X connect 14 0 13 0;
#X connect 22 0 27 1;
#X connect 23 0 27 0;
#X connect 24 0 27 0;
#X connect 25 0 24 0;
#X connect 26 0 22 0;
#X connect 27 0 56 0;
#X connect 27 0 56 1;
#X connect 28 0 29 0;
#X connect 29 0 45 0;
#X connect 31 0 22 0;
#X connect 32 0 22 0;
#X connect 44 0 29 0;
#X connect 45 0 27 0;
#X connect 55 0 54 0;
#X restore 212 555 pd [fexpr~] Examples;
#X obj 92 608 +;
#X obj 304 633 +~;
#X obj 92 633 >;
#X text 102 522 (click on the subpatches to open them), f 13;
#X obj 194 660 random;
#N canvas 411 74 872 635 [value] 0;
#X floatatom 596 202 5 0 0 0 - - - 0;
#X obj 596 137 until;
#X msg 719 138 0;
#X obj 719 168 v i;
#X obj 596 169 expr i = i + 1;
#X msg 596 72 10;
#X obj 596 229 print;
#X obj 261 63 loadbang;
#X obj 221 176 value a;
#X obj 261 149 value b;
#X obj 304 123 value c;
#X obj 91 337 expr (a + b) / c;
#X obj 91 310 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X floatatom 91 371 0 0 0 0 - - - 0;
#X obj 596 103 trigger float bang;
#X obj 697 288 expr i * 2 \; i = i + 1;
#X floatatom 697 334 5 0 0 0 - - - 0;
#X floatatom 771 335 5 0 0 0 - - - 0;
#X obj 697 253 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X text 33 233 All you have to do is just use the variable name into
the expression:, f 27;
#X obj 90 422 expr~ (a + b) / c;
#X obj 90 453 print~;
#X obj 62 422 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X msg 221 97 5;
#X msg 261 97 3;
#X msg 304 97 2.5;
#X obj 91 533 print~;
#X obj 63 502 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X obj 91 502 fexpr~ (a + b) / c;
#X text 325 291 Expressions are output from right to left order in
[expr] \, since they're evaluated from bottom to top. This means you
need to update a variable and call it in the above expression \, check
it =============>, f 51;
#X obj 576 504 v last;
#X obj 450 535 fexpr~ last = $x1[-1] \; $x1[0] - last;
#X obj 601 590 print~;
#X obj 635 555 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X obj 450 504 phasor~ 1000;
#X text 100 98 loading values into [value] objects =======>, f 16
;
#X text 22 15 [expr] \, [expr~] and [fexpr~] can access variables set
into [value] objects.;
#X text 471 14 It is also possible to assign values to variables inside
the expr family of objects with "=" (a.k.a the "store function").,
f 51;
#X text 294 395 You can also assign variables values in [expr~] and
[fexpr~]. But it is not pertinent to do this in [expr~] because it
deals with whole signal vectors and not single values. As for [fexpr~]
\, note that they're evaluated in from top to bottom instead. This
means you need to update a variable and call it in the below expression
\, check the following example:, f 75;
#X connect 0 0 6 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 4 0 0 0;
#X connect 5 0 14 0;
#X connect 7 0 24 0;
#X connect 7 0 25 0;
#X connect 7 0 23 0;
#X connect 11 0 13 0;
#X connect 12 0 11 0;
#X connect 14 0 1 0;
#X connect 14 1 2 0;
#X connect 15 0 16 0;
#X connect 15 1 17 0;
#X connect 18 0 15 0;
#X connect 20 0 21 0;
#X connect 22 0 21 0;
#X connect 23 0 8 0;
#X connect 24 0 9 0;
#X connect 25 0 10 0;
#X connect 27 0 26 0;
#X connect 28 0 26 0;
#X connect 31 1 32 0;
#X connect 33 0 32 0;
#X connect 34 0 31 0;
#X restore 550 497 pd [value];
#X obj 105 258 expr $f1 + $s3[$i2];
#X symbolatom 235 232 7 0 0 0 - - - 0;
#X floatatom 170 231 3 0 0 0 - - - 0;
#X floatatom 105 232 4 0 0 0 - - - 0;
#X obj 278 329 sig~ 1;
#X text 338 328 <= 1st inlet is an audio signal vector/block;
#X obj 74 451 fexpr~ $x1[0] + $y1[-1];
#X text 62 297 [expr~] has an exclusive input variable defined as '$v#'
- which stands for an audio signal 'vector' (or block)., f 85;
#X text 49 395 [fexpr~] has exclusive variable types defined as: '$x#[n]'
(an input audio sample from inlet # indexed by 'n') and '$y#[n]' (an
output audio sample from outlet # indexed by 'n')., f 91;
#X text 307 224 First inlet is a float input that adds to an array
value whose index is defined by an integer input from the second inlet
and the third inlet takes a symbol for the array name., f 50;
#X obj 248 660 array;
#X obj 278 355 expr~ $v1 + $f2;
#X floatatom 401 355 5 0 0 0 - - - 0;
#X text 256 443 for '$x#' \, 'n' has to satisfy: 0 => n > -vector size
;
#X text 256 460 for '$y#' \, 'n' has to satisfy: -1 => n > -vector
size;
#X obj 304 608 sin;
#X text 123 607 - arithmetic operators;
#X text 123 632 - other binary operators;
#X text 333 607 - math functions;
#X text 333 632 - audio operators;
#X obj 295 660 cos~;
#X obj 333 660 wrap~;
#X obj 416 660 abs~;
#X obj 492 660 sqrt~;
#X obj 378 660 exp~;
#X obj 454 660 log~;
#X obj 538 660 pow~;
#X text 51 147 These objects have several built in operators and functions
and the syntax is quite similar to how expressions are written in C.
They receive input variables via the inlets and understand the variable
types: '$f#' (floats) \, '$i#' (integers) and '$s#' (symbols \, used
to represent array names) - '#' is the inlet number (up to 100) as
below:, f 88;
#X text 513 616 updated for Pd version 0.51-3;
#X obj 70 33 expr;
#X obj 63 58 expr~;
#X obj 57 96 fexpr~;
#X text 26 3 Expression evaluation family of objects By Shahrokh Yadegari
- Version 0.57, f 75;
#X text 107 96 - evaluation of audio signal expressions;
#X text 107 58 - evaluation of audio signal expressions;
#X text 107 33 - evaluation of control data expressions;
#X text 121 76 on a vector by vector basis, f 38;
#X text 121 113 on a sample by sample basis, f 38;
#X obj 7 137 cnv 1 730 1 empty empty empty 8 12 0 13 #000000 #000000
0;
#X obj 451 57 bng 17 250 50 0 empty empty empty 17 7 0 10 #ffffff #000000
#000000;
#N canvas 798 148 456 264 reference 0;
#X obj 101 59 inlet;
#X obj 101 190 pdcontrol;
#X obj 101 130 pdcontrol;
#X msg 101 105 dir;
#X msg 101 159 browse \$1/../8.topics/expr.html;
#X text 205 94 this window opens the html reference link via the [pdcontrol]
object., f 25;
#X connect 0 0 3 0;
#X connect 2 0 4 0;
#X connect 3 0 2 0;
#X connect 4 0 1 0;
#X restore 451 91 pd reference;
#X text 471 55 <= Open HTTML reference;
#X obj 8 595 cnv 1 730 1 empty empty empty 8 12 0 13 #000000 #000000
0;
#X text 655 90 <= click;
#N canvas 705 69 575 516 reference 0;
#X obj 8 40 cnv 5 550 5 empty empty INLETS: 8 18 0 13 #202020 #000000
0;
#X obj 8 255 cnv 2 550 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000
0;
#X obj 8 344 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000
0;
#X obj 7 493 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000
0;
#X obj 7 175 cnv 1 550 1 empty empty 'n': 8 12 0 13 #7c7c7c #000000
0;
#X obj 21 7 expr;
#X text 81 49 (arguments set 'n' number of inlets and type);
#X text 99 180 float - if inlet type is '$f#' or '$i#'., f 43;
#X text 92 198 symbol - if inlet type is '$s#' or '$i#'., f 44;
#X obj 7 288 cnv 1 550 1 empty empty 'n': 8 12 0 13 #7c7c7c #000000
0;
#X text 83 261 (number of expressions define 'n' numbers of outlets)
;
#X text 19 371 1) list -;
#X obj 61 7 expr~;
#X obj 109 7 fexpr~;
#X text 99 295 float - (for [expr] only) expression result., f 58
;
#X text 92 314 signal - (for [expr~] and [fexpr~] only) expression
result.;
#X text 163 8 - expression evaluation family of objects.;
#X text 92 216 signal -;
#X text 155 216 if inlet type is '$v#' ([expr~]) or '$x#' ([fexpr~])
\, leftmost inlet is always signal in [expr~]/[fexpr~].;
#X obj 7 75 cnv 1 550 1 empty empty leftmost: 8 12 0 13 #7c7c7c #000000
0;
#X text 31 136 clear <symbol> -;
#X text 101 80 bang - in [expr]: evaluate expression., f 64;
#X text 59 98 set <list> - in [fexpr~]: set values for previous input/output
values., f 70;
#X text 59 116 stop/start - in [fexpr~]: stop/start computation.,
f 70;
#X text 150 136 in [fexpr~]: clear input/output memory \, optional
symbol specifies a specific input (such as x1) or output (y1)., f
57;
#X text 90 371 expression including operators \, functions \, inlet
types \, float and symbols )for array names and variables). See html
reference and examples for all operators and function. Smicolons create
more expressions (and outlets). Inlet type is has the format '$t#'
where 't' is type (f \, i \, s \, v and x) and # is the number \, the
'x' type for fexpr~ also has a sample number in brackets and there's
also a 'y' variable for output samples with previous samples in brackets
as well (default: output zeros)., f 65;
#X restore 561 91 pd reference;
#X connect 18 0 17 2;
#X connect 19 0 17 1;
#X connect 20 0 17 0;
#X connect 21 0 28 0;
#X connect 29 0 28 1;
#X connect 56 0 57 0;
