#N canvas 541 61 544 632 12;
#X declare -stdpath ./;
#X obj 245 421 cos~;
#X obj 288 403 +~ -0.25;
#X obj 288 426 cos~;
#X obj 170 477 *~;
#X obj 223 477 *~;
#X obj 170 503 -~;
#X floatatom 245 350 5 0 0 0 - - - 0;
#X text 52 387 pair of allpass;
#X text 52 403 filters to make;
#X text 52 419 90 degree phase;
#X text 45 434 shifted versions;
#X text 357 386 cosine and sine waves;
#X obj 170 544 output~;
#X obj 245 375 phasor~;
#X text 356 401 to form the real and;
#X text 356 417 imaginary part of a;
#X text 356 434 complex sinusoid;
#X text 43 59 The signal sideband modulator gives you only one sideband for each frequency in the input signal (whereas ring modulation gave both a positive and negative sideband). You can set the shift frequency positive to shift all frequencies upward \, or negative to shift them downwards., f 64;
#X text 43 139 The technique is to filter the input into two versions \, 90 degrees out of phase \, which can be interpreted as the real and imaginary part of a complex signal with positive frequencies only. You can then form the (complex) product of this with a (complex) sinusoid to modulate upward or downward in frequency., f 64;
#X obj 170 412 hilbert~;
#X text 254 478 <-- complex multiplier (calculates real part), f 22;
#X text 289 350 <-- shift frequency;
#X text 43 222 The [hilbert~] object is an abstraction in the 'extra' library. It takes a signal and creates two copies that are 90 degrees out of phase., f 64;
#X obj 36 18 cnv 5 5 25 empty empty Single\ Sideband\ Modulation\ (AKA\ Freq.\ Shifter) 15 13 0 16 #dfdfdf #202020 0;
#X text 52 297 sample loop for test signal -->, f 15;
#X obj 170 284 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X text 194 282 choose another sample;
#N canvas 555 154 649 577 test-loop 0;
#X obj 121 511 outlet~;
#N canvas 0 0 450 300 (subpatch) 0;
#X array \$0-sample 155944 float 2;
#X coords 0 1 155944 -1 279 142 1 0 0;
#X restore 308 268 graph;
#X obj 121 433 *~;
#X obj 163 394 phasor~;
#X obj 121 246 soundfiler;
#X obj 121 66 loadbang;
#X obj 121 94 bng 19 250 50 0 empty empty empty 0 -6 0 8 #dfdfdf #000000 #000000;
#X obj 445 432 declare -stdpath ./;
#X msg 188 276 \$1;
#X obj 163 307 swap;
#X obj 163 335 /;
#X floatatom 163 365 10 0 0 0 - - - 0;
#X obj 175 160 symbol \$0-sample;
#X obj 121 469 tabread4~ \$0-sample;
#X obj 42 115 openpanel;
#X msg 121 124 ../sound/bell.aiff;
#X msg 121 215 read -resize \$1 \$2;
#X obj 121 188 pack s s;
#X obj 121 160 t a b;
#X floatatom 156 433 9 0 0 0 - - - 0;
#X floatatom 203 308 6 0 0 0 - - - 0;
#X text 204 327 sample rate, f 6;
#X text 223 434 length;
#X text 362 144 initialize patch \, load file into array and play loop., f 22;
#X obj 42 75 bng 19 250 50 0 empty empty empty 0 -6 0 8 #dfdfdf #000000 #000000;
#X obj 42 41 inlet;
#X connect 2 0 13 0;
#X connect 3 0 2 0;
#X connect 4 0 9 0;
#X connect 4 0 19 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 15 0;
#X connect 8 0 9 1;
#X connect 8 0 20 0;
#X connect 9 0 10 0;
#X connect 9 1 10 1;
#X connect 10 0 11 0;
#X connect 11 0 3 0;
#X connect 12 0 17 1;
#X connect 13 0 0 0;
#X connect 14 0 18 0;
#X connect 15 0 18 0;
#X connect 16 0 4 0;
#X connect 17 0 16 0;
#X connect 18 0 17 0;
#X connect 18 1 12 0;
#X connect 19 0 2 1;
#X connect 24 0 14 0;
#X connect 25 0 24 0;
#X restore 170 312 pd test-loop;
#X connect 0 0 3 1;
#X connect 1 0 2 0;
#X connect 2 0 4 1;
#X connect 3 0 5 0;
#X connect 4 0 5 1;
#X connect 5 0 12 0;
#X connect 6 0 13 0;
#X connect 13 0 1 0;
#X connect 13 0 0 0;
#X connect 19 0 3 0;
#X connect 19 1 4 0;
#X connect 25 0 27 0;
#X connect 27 0 19 0;
