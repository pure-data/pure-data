#N canvas 374 38 902 800 12;
#X declare -stdpath ./;
#N canvas 0 0 450 300 (subpatch) 0;
#X array table21 44103 float 2;
#X coords 0 1.02 44103 -1.02 264 165 1;
#X restore 575 321 graph;
#X obj 421 581 loadbang;
#X floatatom 79 211 6 0 0 0 - - - 0;
#X obj 79 536 +~ 1;
#X obj 419 436 adc~ 1;
#X obj 250 663 *~;
#X floatatom 167 261 6 0 0 0 - - - 0;
#X obj 109 575 +~;
#X obj 167 571 samphold~;
#X obj 79 448 samphold~;
#X obj 79 511 *~;
#X floatatom 227 261 7 0 0 0 - \$0-cents - 0;
#X obj 175 330 t b f;
#X obj 227 365 /;
#X obj 421 635 soundfiler;
#X obj 268 566 -~ 0.5;
#X obj 268 592 *~ 0.5;
#X obj 268 625 cos~;
#X obj 250 701 output~;
#X obj 109 610 tabread4~ table21;
#X text 514 588 v-- re-read original table;
#X text 626 500 --- 44103 samples ---;
#X obj 227 415 phasor~;
#X obj 419 516 tabwrite~ table21;
#X msg 421 608 read ../sound/voice.wav table21;
#X obj 438 473 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X obj 37 18 cnv 5 5 25 empty empty Calculating\ Loop\ Frequency\ as\ function\ of\ Transposition 15 13 0 16 #dfdfdf #202020 0;
#X text 462 472 <-- record;
#X floatatom 227 391 8 0 0 0 - - - 0;
#X obj 82 183 hsl 162 19 0 1000 0 0 empty \$0-size chunk\ size\ (ms) -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 170 229 hsl 162 19 -250 1000 0 0 empty \$0-read-point read\ point\ (ms) -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#N canvas 623 232 323 359 init 0;
#X text 57 23 This subpatch initializes the patch and loads values in number boxes., f 29;
#X obj 79 94 loadbang;
#X obj 79 149 f \$0;
#X obj 79 121 bng 19 250 50 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000;
#X obj 79 266 declare -stdpath ./;
#X msg 79 173 \; \$1-cents 0 \; \$1-read-point 0 \; \$1-size 250;
#X connect 1 0 3 0;
#X connect 2 0 5 0;
#X connect 3 0 2 0;
#X restore 412 171 pd init;
#X obj 79 415 * 44.1;
#X obj 167 536 * 44.1;
#X text 88 312 chunk size in seconds, f 10;
#X obj 227 300 expr pow(2 \, $f1/1200);
#X text 280 261 <-- transposition in cents (100ths of a halftone), f 26;
#X text 262 354 divide speed change by chunk size to get loop frequency, f 28;
#X obj 175 300 / 1000;
#X text 314 625 envelope;
#X floatatom 227 328 9 0 0 0 - - - 0;
#X text 298 328 speed change ratio;
#X text 64 67 This patch calculates the loop frequency as a function of desired transposition. We get the inverse of the chunk size in seconds \, which corresponds to its frequency in Hz andmultiply it by a transposition ratio. A transposition in cents is also provided and converted to ration., f 65;
#X text 567 71 Notice now in order to avoid Doppler effects when the chunk size changes we have a sample and hold unit \, which can be an issue if you're dealing with very low frequencies that never end up triggering the sample and hold..., f 39;
#X text 569 177 You might also want to have a way to retrigger the loop to sync it with some other process. By the time we had all this built the patch would be fairly involved. For now \, we'll move on to the next example..., f 39;
#X connect 1 0 24 0;
#X connect 2 0 32 0;
#X connect 2 0 38 0;
#X connect 3 0 7 0;
#X connect 4 0 23 0;
#X connect 5 0 18 0;
#X connect 6 0 33 0;
#X connect 7 0 19 0;
#X connect 8 0 7 1;
#X connect 9 0 10 0;
#X connect 10 0 3 0;
#X connect 11 0 35 0;
#X connect 12 0 13 0;
#X connect 12 1 13 1;
#X connect 13 0 28 0;
#X connect 15 0 16 0;
#X connect 16 0 17 0;
#X connect 17 0 5 1;
#X connect 19 0 5 0;
#X connect 22 0 8 1;
#X connect 22 0 15 0;
#X connect 22 0 9 1;
#X connect 22 0 10 1;
#X connect 24 0 14 0;
#X connect 25 0 23 0;
#X connect 28 0 22 0;
#X connect 29 0 2 0;
#X connect 30 0 6 0;
#X connect 32 0 9 0;
#X connect 33 0 8 0;
#X connect 35 0 40 0;
#X connect 38 0 12 0;
#X connect 40 0 13 0;
