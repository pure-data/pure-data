#N canvas 515 38 550 623 12;
#X declare -stdpath ./;
#X floatatom 104 228 7 0 130 0 - - - 0;
#X floatatom 122 362 7 0 0 0 - - - 0;
#X text 299 487 write to delay line;
#X text 271 391 read from delay line;
#X text 135 449 add the original and the delayed signal;
#X obj 104 272 mtof;
#X msg 178 266 1;
#X obj 104 325 *~;
#X obj 104 448 +~;
#X obj 122 419 *~ 0.7;
#X obj 178 325 *~;
#X obj 104 527 output~;
#X obj 104 296 phasor~;
#X obj 132 488 delwrite~ G02-del 2000;
#X obj 268 557 declare -stdpath ./;
#X text 33 69 You can feed the result of a [delread~] module back into its own [delwrite~] \, as long as you're careful about stability. For delays below 30 msec \, you can frequently hear the resonant pitch. For longer delay times you get the famous old delay loop effect., f 66;
#X text 179 362 <-- set delay time;
#X text 177 421 feedback gain (less than 1 for stability);
#X obj 178 296 adsr 1 100 1000 0 0;
#X obj 122 391 delread~ G02-del 150;
#X text 33 138 We've added an amplitude control here so that the test oscillator only speaks while you're dragging the pitch up and down or when hitting 'bang'. Be sure to try shift-dragging on the pitch control., f 66;
#X text 323 294 ADSR only uses attack and decay stages, f 22;
#X obj 54 24 cnv 5 5 25 empty empty Delays\ With\ Feedback 15 13 0 16 #dfdfdf #202020 0;
#X text 159 227 <-- click and drag or set pitch;
#X text 209 265 <-- click to retrigger;
#X connect 0 0 5 0;
#X connect 0 0 6 0;
#X connect 1 0 19 0;
#X connect 5 0 12 0;
#X connect 6 0 18 0;
#X connect 7 0 8 0;
#X connect 8 0 11 0;
#X connect 8 0 13 0;
#X connect 9 0 8 1;
#X connect 10 0 7 1;
#X connect 12 0 7 0;
#X connect 18 0 10 0;
#X connect 18 0 10 1;
#X connect 19 0 9 0;
