#N canvas 429 79 782 607 12;
#X declare -stdpath ./;
#X obj 266 211 line~;
#X obj 266 187 pack 0 50;
#X floatatom 220 86 4 0 200 0 - bandwidth - 0;
#X obj 142 148 *~;
#X obj 220 112 / 10;
#X obj 220 136 moses 0;
#X msg 220 160 0;
#X text 258 86 bandwidth;
#X obj 124 181 *~;
#X obj 88 134 sig~ 1;
#X obj 88 235 /~;
#X obj 106 209 +~;
#X text 157 181 X^2;
#X text 136 212 1+X^2;
#X text 123 237 1/(1+X^2);
#N canvas 0 0 450 300 (subpatch) 0;
#X array F04-signal 882 float 0;
#X coords 0 1.02 882 -1.02 200 130 1;
#X restore 537 372 graph;
#N canvas 0 0 450 300 (subpatch) 0;
#X array F04-spectrum 259 float 0;
#X coords 0 1.01 258 -0.008 256 200 1;
#X restore 479 69 graph;
#X text 556 509 ---- 0.02 seconds ----;
#X text 506 268 2;
#X text 537 268 4;
#X text 476 268 0;
#X text 569 268 6;
#X text 602 268 8;
#X text 630 268 10;
#X text 662 268 12;
#X text 694 268 14;
#X obj 88 330 output~;
#N canvas 745 198 546 520 fft 0;
#X text 60 23 This subpatch computes the spectrum of the incoming signal with a (rectangular windowed) FFT. FFTs aren't properly introduced until much later.;
#X obj 364 143 block~ 4096;
#X text 360 115 Window size;
#X obj 43 105 inlet~;
#X obj 142 264 inlet;
#X obj 63 136 rfft~;
#X obj 63 169 *~;
#X obj 95 169 *~;
#X obj 63 199 sqrt~;
#X obj 63 225 biquad~ 0 0 0 0 1;
#X text 127 137 Fourier series;
#X text 132 190 magnitude;
#X text 130 175 calculate;
#X text 105 104 signal to analyze;
#X text 194 216 delay two samples;
#X text 192 234 for better graphing;
#X obj 178 328 metro 500;
#X obj 178 292 inlet;
#X text 231 290 toggle to graph repeatedly, f 15;
#X text 185 264 bang to graph once;
#X obj 63 249 /~ 4096;
#X obj 142 360 b;
#X obj 143 396 tabwrite~ F04-spectrum;
#X obj 43 422 tabwrite~ F04-signal;
#X connect 3 0 5 0;
#X connect 3 0 23 0;
#X connect 4 0 21 0;
#X connect 5 0 6 0;
#X connect 5 0 6 1;
#X connect 5 1 7 0;
#X connect 5 1 7 1;
#X connect 6 0 8 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 9 0 20 0;
#X connect 16 0 21 0;
#X connect 17 0 16 0;
#X connect 20 0 22 0;
#X connect 21 0 22 0;
#X connect 21 0 23 0;
#X restore 121 293 pd fft;
#X obj 140 268 bng 19 250 50 0 empty empty empty 0 -6 0 8 #dfdfdf #000000 #000000;
#X obj 181 293 tgl 19 0 empty empty empty 0 -6 0 8 #dfdfdf #000000 #000000 0 1;
#X obj 142 121 osc~;
#X text 32 418 Here we use waveshaping to make another form of pulse train. This one has a neat spectrum: the partials drop off exponentially (with the "bandwidth" controlling the rate of dropoff.) In later patches we'll use a wavetable to do the waveshaping but for simplicity \, it's done algebraically here. The oscillator runs at half the fundamental frequency. The symmetry of the waveshaping doubles the frequency of the output., f 66;
#X text 741 253 0;
#X text 738 66 1;
#X obj 142 96 r freq/2;
#X text 162 268 <-- graph once;
#X text 202 292 <-- repeatedly;
#X text 513 301 ------ partial number ------;
#X obj 25 26 cnv 5 5 25 empty empty Another\ Pulse\ Width\ Modulator\ Algorithm 15 13 0 16 #dfdfdf #202020 0;
#X text 32 527 This is the form of pulse train used in the original Phase Aligned Formant (PAF) algorithm \, which was protected by patents belonging to IRCAM (from 1993 to 2011)., f 66;
#N canvas 264 120 348 434 init 0;
#X obj 159 176 samplerate~;
#X obj 159 204 / 512;
#X obj 159 260 s freq/2;
#X floatatom 159 232 9 0 0 0 - - - 0;
#X obj 97 353 declare -stdpath ./;
#X obj 107 291 s bandwidth;
#X obj 107 136 loadbang;
#X msg 107 262 50;
#X text 45 61 This subpatch initializes the patch and loads values into number boxes., f 35;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 3 0 2 0;
#X connect 6 0 0 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X restore 255 354 pd init;
#X connect 0 0 3 1;
#X connect 1 0 0 0;
#X connect 2 0 4 0;
#X connect 3 0 8 0;
#X connect 3 0 8 1;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 5 1 1 0;
#X connect 6 0 1 0;
#X connect 8 0 11 1;
#X connect 9 0 10 0;
#X connect 9 0 11 0;
#X connect 10 0 27 0;
#X connect 10 0 26 0;
#X connect 11 0 10 1;
#X connect 28 0 27 1;
#X connect 29 0 27 2;
#X connect 30 0 3 0;
#X connect 34 0 30 0;
